**操作系统**  
《计算机操作系统(第四版)》  
[王道计算机考研-操作系统](https://www.bilibili.com/video/BV1YE411D7nH)  

常见的操作系统有:  
- 电脑: Windows, Linux, Mac OS.
- 手机: Android(安卓), iOS(苹果).

# 引论

操作系统(operating system, os)是配置在计算机硬件上的第一层软件(属于系统软件), 用来控制和管理整个计算机系统的硬件和软件资源, 并为用户和应用程序提供一个简单的接口和环境.

## 操作系统的功能和目标

1. 作为用户与计算机硬件系统之间的接口 - 方便用户使用  
    - 命令接口: 允许用户直接使用
    - 程序接口: 允许用户通过程序间接使用
    - GUI: 现代操作系统中最流行的图形用户接口


2. 作为系统资源的管理者 - 安全, 高效  
    - 处理机管理
    - 储存器管理
    - 文件管理
    - 设备管理

3. 实现对计算机资源的抽象
    为了方便用户使用I/O设备, 在裸机上安装操作系统, 实现对I/O设备的操作细节, 从而用户无需关心I/O是如何具体实现的.  
    通常把覆盖了这样的软件的机器称为扩充机器或虚拟机.

具体的功能分类:  
1. 处理机管理(进程控制, 进程同步, 进程通信, 调度)
2. 存储器管理(内存分配, 内存保护, 地址映射, 内存扩充)
3. 设备管理(缓冲管理, 设备分配, 设备处理)
4. 文件管理(文件存储空间的管理, 目录管理, 文件的读写管理和保护)
5. 用户接口(用户接口, 程序接口)

现代操作系统的新功能:  
1. 系统安全
2. 网络的功能和服务
3. 支持多媒体

## 操作系统的基本特征

1. 并发  
    并发指两个或多个事件在同一时间间隔内发生. 这些事件宏观上是同时发生的, 但微观上是交替发生的.  
    并行: 指两个或多个事件在同一时刻发生.  

2. 共享  
    - 互斥共享方式: 系统中的某些资源, 如打印机、磁带机等, 虽然可以提供给多个进程使用, 但在一段时间内只允许一个进程访问该资源.  
    - 同时共享方式: 系统中的某些资源, 允许在一段时间内由多个进程"同时"访问.

如果失去并发性, 则共享性失去意义.  
如果失去共享性, 就难以实现并发.  
并发和共享是多用户(多任务)OS的两个最基本的特征, 它们互为存在条件.  

3. 虚拟  
    在OS中, 把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为"虚拟".  
    - 时分复用技术: 提高设备对空闲时间的利用.  
    - 空分复用技术: 提高存储空间的利用率.

4. 异步  
    指在多道程序环境下, 系统允许多个进程并发执行, 但由于资源有限, 进程的执行并不是一贯到底的, 而是"走走停停", 以不可预知的速度进行.  

## 操作系统发展与分类

1. 手工操作方式  
    用穿孔的纸带或卡片进行输入.  
    缺点: 用户独占全机, 人工装卸时CPU等资源处于空闲状态.

2. 单道批处理系统  
    利用外围机事先将程序与数据录入磁带中, 再高速调入内存.  
    在一定程度上缓解了人机速度矛盾, 但CPU仍有大量时间是在等待I/O完成.  

3. 多道批处理系统  
    多道程序并发执行, 共享计算机资源. 资源的利用率大幅提升, CPU和其他资源保持"忙碌"状态, 系统吞吐量大.  
    但是用户的响应时间长, 且没有人机交互能力(在程序运行时, 不能与自己的作业进行交互)

4. 分时操作系统  
    计算机以时间片(如30ms)为单位轮流为各个用户/作业服务, 各个用户可通过终端与计算机进行交互.  
    主要根据人们所能接受的等待时间决定响应时间(1~3s).
    主要优点: 解决了人机交互问题. 允许多个用户同时使用一台计算机, 并且操作互相独立.  
    主要缺点: 不能优先处理一些紧急任务.

5. 实时操作系统  
    能优先响应一些紧急任务, 不需要时间片排队.  
    在实时操作系统的控制下, 计算机系统接收到外部信号后及时进行处理, 并且要在严格的时限内处理完事件. 主要的特点是**及时性和可靠性**.  
    根据严格程度分为 **硬实时系统**与**软实时系统**.  
    响应时间由控制对象所要求的截止时间来确定(毫秒级).  

6. 其他操作系统  
    - 网络操作系统
    - 分布式操作系统
    - 个人计算机操作系统

## os的运行机制与体系结构

### 运行机制

指令: 处理器(CPU)能识别, 执行的最基础命令.  
    - 特权指令(不允许用户程序使用): 如内存清零指令  
    - 非特权指令: 如普通的运算指令  

两种处理器状态:  
    - 用户态(目态): CPU只能执行非特权指令  
    - 核心态(管态): 可执行所有指令  

两种程序:  
    - 核心程序: 操作系统的内核程序是系统的管理者, 运行在核心态.  
    - 应用程序: 普通应用程序只能执行非特权指令, 运行在用户态.  

内核是计算机上配置的底层软件, 是操作系统最基本、最核心的部分。  
实现操作系统内核功能的那些程序就是内核程序。  
不同的操作系统对内核功能的划分可能并不一样。

### 体系结构

- 大内核: 将操作系统的主要功能模块都作为系统的内核, 运行在核心态.  
    - 优点: 高性能
    - 缺点: 内核代码庞大, 结构混乱, 难维护

- 微内核: 只把最基本的功能保留在内核.  
    - 优点: 内核功能少, 结构清晰, 方便维护
    - 缺点: 需要频繁地在核心态和用户态之间切换, 性能低


## 中断和异常

### 中断机制的诞生

中断机制是为了实现进程的并发.  
本质: 发生中断就意味着**需要操作系统介入,开展管理工作**.


- 当CPU收到计时部件发出的中断信号(每过一个时间片), 会切换到核心态对中断进行处理, 进行进程的切换.  
- 当进程发出**系统调用**时(内中断信号), CPU切换为核心态, 对中断进行处理.  
- 当I/O完成时, 设备会向CPU发出中断信号, CPU进行处理...


1. 当中断发生时,CPU立即进入核心态.★
2. 当中断发生后, 当前进程暂停, 并由操作系统内核对中断进行处理.
3. 对于不同的中断信号, 会进行不同的处理.

中断是从用户态转换为核心态的唯一途径.★  
从核心态转换为用户态是通过执行一个特权指令, 将程序状态字(PSW)的标志位设置为"用户态".  

### 中断的分类★

中断分为**内中断**和**外中断**, 外中断为狭义的中断.  
**内中断的信号来自CPU内部**, 与当前执行的程序有关; **外中断来自CPU外部**, 与当前执行的程序无关.  

内中断(也称异常、例外、陷入), 可分为自愿中断(指令中断)与强迫中断, 强迫中断分为硬件故障与软件中断.  
外中断分为外设请求和人工干预.  

### 外中断的处理过程

1. 执行完每个指令后, CPU都要检查当前是否有外部中断信号.
2. 检查到外部中断信号时, 需要保护被中断进程的CPU环境.
3. 根据中断信号类型转入相应的中断处理程序.
4. 恢复原进程的CPU环境并退出中断, 返回原进程继续往下执行.


## 系统调用

操作系统作为用户和计算机硬件之间的接口, 需要向上提供一些简单易用的服务. 主要包括命令接口和程序接口. 其中, 程序接口就是由一组系统调用组成.  

"系统调用" 是操作系统提供给应用程序(程序员/编程人员)使用的接口, 可以理解为一种可供应用程序调用的特殊函数, 应用程序可以发出系统调用请求来获得操作系统的服务.

### 系统调用的作用

应用程序提供系统调用请求操作系统的服务.  
系统中的各种共享资源都由操作系统统一管理, 因此在用户程序中, 凡是与资源有关的操作(如存储分配、I/O操作、文件管理等), 都必须提供系统调用的方式向操作系统提出服务请求, 由操作系统代为完成.  
这样可以保证系统的稳定性和安全性, 防止用户进行非法操作.  


- 系统调用会使处理器从用户态进入核心态.
- 一些高级语言(如C++)也是通过封装系统调用来操作系统资源.

# 进程

## 前趋图

前趋图(Directed Acyclic Graph, DAG), 是指一个有向无循环图, 它用于描述进程之间的先后顺序.  
Pi -> Pj, 表示在Pj 执行之前Pi 必须完成. 此时称Pi 是Pj的**直接前趋**, 而称Pj 是Pi 的**直接后继**.  没有前趋的结点称为**初始结点**, 没有后继的结点称为**终止结点**.  
每个结点还有一个**重量**属性.  

### 程序顺序执行与并发执行
- 顺序执行的特点  
  - 顺序性
  - 封闭性: 程序运行时独占全机资源.
  - 可再现性: 重复执行, 结果相同.

- 并发执行的特点  
  - 间断性
  - 失去封闭性
  - 不可再现性

## 进程的描述

### 进程的定义和特征

系统为每个运行的程序配置了一个数据结构, 称为**进程控制块(PCB)**.  
程序段、数据段、PCB三部分组成了**进程实体(又称进程映像)**, 进程实体简称进程.  
创建进程即创建进程实体的PCB, 撤销实体即撤销进程的PCB.  
- PCB是进程存在的唯一标识.  

引入进程实体后, 进程的定义:  
进程是进程实体的运行过程, 是系统进行资源分配和调度的一个独立单位.  

PCB组成:  
    - 进程标识符: 用于唯一地标识一个进程(不重复). 
      分为, **外部标识符**和**内部标识符**. 外部标识符方便用户(进程)对进程的访问, 内部标识符方便系统对进程的使用.  
    - 处理机状态: 各种寄存器值. 在进程切换时记录进程的运行情况.   
    - 进程调度信息: 包括, 进程当前状态, 进程优先级等.  
    - 进程控制信息: 包括, 程序和数据的地址, 资源清单等.
    

进程的特征:  
    1. 动态性: **动态性是进程最基本的特征**. 进程的实质是进程实体的执行过程, 进程实体有一定的生命周期.  
    2. 并发性: 并发.  
    3. 独立性: 进程实体是一个能独立运行, 独立获得资源和独立接受调度的基本单位.  
    4. 异步性: 进程的执行速度不可预知.  


### ★进程的状态与转换

三种基本状态☆:  
    - 就绪态: 进程已分配到除CPU以为的所有必要资源, 只要再获得CPU, 便可立即执行.  
    - 执行态: 程序正在执行.
    - 阻塞态: 进程再执行过程中由于发生某事件(如, I/O请求, 申请缓冲区失败等)暂时无法继续执行的状态.

三种状态的转换☆: 
    就绪状态的进程被调度时转换为运行态.  
    运行态的进程当分配的时间片已完会转换为就绪态.  
    运行态的进程执行受阻(申请的资源正被使用等)转换为阻塞态.  
    阻塞态的进程的阻塞被解除会转换为就绪态.  

另外两种状态: 
  - 创建状态: 创建一个进程是个复杂的状态, 有多个步骤. 此时的进程处于创建状态.  
  - 终止状态: 进程的终止有两个步骤, 操作系统进行善后处理和PCB清零, 回收空间. 此时为终止状态.  

#### 挂起操作

当挂起操作作用于某个进程时, 意味着此时该进程处于静止状态. 如果进程正在执行, 它将暂停执行. 若原本处于就绪状态, 则该进程此时暂时不接受调度.  
与之对应的操作为激活操作.  

挂起的原因:  
    1. 终端用户的需要
    2. 父进程的需要: 
    3. 负荷调节的需要: 挂起不重要的进程, 保证系统正常运行.  
    4. 操作系统的需要: 检查运行中的资源使用情况或进行记账.  

转换:  


### 进程的组织

多个进程之间的组织方式:  
1. 线性方式: 将系统所有的PCB都组织在一张线性表中. 实现简单, 开销小, 但查找需要扫描全表, 适合进程数目不多的系统.  
2. 链接方式: 将具有相同状态的进程的PCB链接成一个队列. 通常按优先级将PCB从高到低排列.  
3. 索引方式: 根据进程状态的不同, 建立几张索引表.

## 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理, 它 具有创建新进程、撤销已有进程、实现进程状态转换等功能.  

用**原语**实现进程控制. 原语的特点是**执行期间不允许中断**. 这种不可中断的操作即**原子操作**.

### 进程的创建

在OS中, 允许一个进程创建另一个进程, 通常分别称为父进程与子进程, 子进程可以继承父进程的所拥有的资源.  
当子进程被撤销时应归还其资源; 当父进程撤销时, 应同时撤销其所有子进程.  
在Windows中不存在这种进程的层次结构, 所有进程的地位相同. 但进程创建另一个进程时会获得"句柄", 用来控制被创建的进程.  

引发创建进程的事件:  
    - 用户登录: 在分时系统中, 用户登录成功后系统会为用户创建一个进程.  
    - 作业调度: 作业被调度时会为它们创建进程.  
    - 提供服务: 用户程序提出请求后, 系统会创建进程.  
    - 应用请求: 用户进程创建子进程, 以便完成特定任务.  

进程的创建:  
    1. 申请空白PCB, 获得唯一数字标识符.  
    2. 分配其所需的资源.  
    3. 初始化PCB.  
    4. 插入就绪队列.  

### 进程的终止

- 正常结束
- 异常结束: 发生异常事件, 使程序无法继续运行. 越界, 非法指令, 运行超时, 算术运算错误等.  
- 外界干预: 操作员或系统干预, 父进程请求, 父进程终止.  

终止过程:  
    1. 从PCB集合中找到终止进程的PCB.  
    2. 若进程处于执行状态, 则立即终止.
    3. 终止其子进程.  
    4. 将其资源归还给其父进程或系统.  
    5. 将PCB移出PCB队列.  


### 阻塞与唤醒

- 向系统请求共享资源失败
- 等待某种操作的完成
- 新数据尚未到达
- 等待新任务到达

☆阻塞是进程自身的一种**主动**行为.  

当上述阻塞原因解决后会唤醒进程. 


## 进程同步

进程同步机制的主要任务, 是对多个相关进程在执行次序上进行协调, 使并发执行的诸进程之间能按照一定的规则(或时序)共享系统资源, 从而**使程序的执行具有可再现性**.  

### 基本概念

- 两种形式的制约关系
  - 间接相互制约关系  
    某些资源在同一时刻只能有一个进程访问, 多个同时申请此类资源的进程形成间接相互制约关系.  
  - 直接相互制约关系  
    为了完成某个任务而建立了多个进程，这些进程需要合作，形成直接制约关系.  

- 临界资源
  在一个时间段内, 只允许一个进程访问的资源.  
  防止多个进程并发时, 对资源的使用或对数据的读写产生混乱.  

- 临界区
  每个进程中访问临界资源的那段代码称为临界区.  

访问临界区:
    - 进入区: 在访问之前对检查临界资源是否正在被访问.
    - 临界区
    - 退出区: 释放临界资源.  
    - 剩余区: 除此之外的其他代码

- 同步机制应遵守的规则
  - 空闲让进: 空闲时允许访问.
  - 忙则等待: 其他想进入临界区的检查必须等待.
  - 有限等待: 应保证在有限时间内进入临界区.
  - 让权等待: 不能进入临界区时, 应释放处理机.  

### 硬件同步机制

虽然可以利用软件方法解决诸进程互斥进入临界区的问题, 但有一定难度, 并且存在很大的局限性, 因而现在已经很少使用.  

1. 关中断:  
    关中断后不允许当前进程被中断, 也必要不会发生进程切换, 直到释放.  
    优点: 简单, 高效.  
    缺点: 不适用于多处理机, 不适用于用户进程(开/关中断指令只能运行在内核态), 关中断时间过长影响系统效率.  

2. Test-and-Set:  
    硬件指令 - "测试并建立"指令TS(Test-and-Set).  
    这条指令可以看作一个函数过程, 其执行过程不可分割.  
    为每个临界资源设置一个布尔变量, 传入TS函数, 一直循环到通过.  

3. Swap指令:  
    ...  


### ★信号量机制

- 整形信号量机制:  
    以一个整形变量(S)表示资源数量.  
    当请求资源时, 调用 wait(S)原子操作, 如果 S <= 0, 等待并不断测试; 如果 S > 0, 则 S--, 可以使用资源.  
    使用完后, 调用 signal(S)原子操作, S++.  

- 记录型信号:  
    用一个整形变量(value)表示资源的数目.  
    进行 wait 操作时, value--, 如果 value < 0, 表示无资源空闲, 此进程自我阻塞并插入等待列表.  
    进行 signal 操作时, value++, 如果 value <= 0, 表示有进程在等待资源, 再调用 wakeup 原语, 将等待列表的第一个进程唤醒.  

- AND型信号量:  
    当进程需要多个共享资源时, 如果一个一个地获得资源, 在未获得所需的所有资源前无法继续而又不会释放已有资源, 容易形成死锁.  
    AND同步机制: 将进程在整个运行过程中需要的所有资源, 一次全部分配, 用完一起释放.  

- 信号量集:  
    进程需要的同一资源的数量可能不止一个, 而之前的信号量只能 +1, -1. 
    在信号量集机制中, ti表示该资源的分配下限, 要求 Si >= ti, 否则不予分配.  
    di表示进程对该资源的需求量, 分配时, Si = Si - di.  
    Swait(S1,t1,d1, ..., Sn,tn,dn);  
    Ssignal(S1, d1, ..., Sn, dn);  
    
    几种特殊情况:  
    1. Swait(S, d, d), 一个信号量, 资源大于等于 d 时可分配 d 个.  
    2. Swait(S, 1, 1), 一般的记录型或互斥信号量.  
    3. Swait(S, 1, 0), 特殊且有用的信号量操作. 当 S >= 1 时, 允许多个进程进入; 当 S = 0 时, 阻止任何进程进入. 相当于一个可控开关.   


### 信号量的应用

- 实现进程互斥  
    设置一互斥信号量 mutex, 初始值为 1.  

- 实现前驱关系  
    将共享信号量初值设为 0, 等待前驱进程释放, 唤醒后继进程.


### 管理机制

...

## 经典的进程同步问题

### 生产者-消费者问题


系统中有一组生产者进程和一组消费者进程, 生产者进程每次生产一个产品(指某种数据)放入缓冲区, 消费者进程每次从缓冲区中取出一个产品使用.  
生产者, 消费者共享一个初始为空, 大小为 n 的缓冲区.  
缓冲区未满时, 生产者可将产品放入.  
缓冲区不空时, 消费者可取出产品.  
各进程互斥访问缓冲区.  

应有两个信号量, 一个用来实现互斥访问, 一个用来控制资源.  

如果用记录型信号量, 需要先对资源信号量判断, 再判断互斥, 否则可能会产生死锁.  


### 哲学家进餐问题

五个哲学家共用一张圆桌, 分别坐在周围的五张椅子上, 在圆桌上有五个碗和五根筷子. 他们交替思考和进餐, 进餐时使用其左边和右边的筷子. 只有拿到两只筷子时才能进餐.  

每一只筷子由一个信号量表示, 其初值为1(互斥).  

如果允许先获得一只筷子, 等待另一只筷子(记录型信号量), 则可能每人拿上一只筷子形成死锁.  
解决: 1. 进餐进餐同时最多有四个. 2. 奇数编号哲学家先拿左边的筷子, 偶数先拿右边的筷子.  

AND型信号量就没有这个问题.   

### 读者-写者问题

一个数据文件或记录可被多个进程共享, 有读进程和写进程.  
允许多个进程同时读同一个共享对象, 但不允许写进程与其他读或写进程同时访问.  

记录型信号量实现, 一个信号量(wmutex)实现读写互斥, 一个信号量(readcount)表示读进程的数量. readcount 的访问本身也是互斥的, 需要一个互斥信号量(rmutex).  
读进程访问, 如果 readcount 不为零, 则可直接访问, 且 readcount++; 如果为零, 表示没有读进程, 继续判断, 如果 wmutex == 1, 表示没有进程, 则可访问, 为零则等待.  
写进程访问需要 wmutex == 1.  

当读进程过多时, 写进程一直会等待, 需要进行限制.  
可以用一个信号量(mx)表示有写进程需要访问, 之后会阻止其后的读进程进行访问. 等待已在访问的所有读进程退出后进行写操作, 完成后释放读进程访问权. Swait(mx, 1, 0).  
还可以设置一个信号量控制读进程的最大数量.  


## 进程通信

**进程通信即进程之间的信息交换.**  
进程是分配系统资源的单位(包括内存地址空间), 因此各进程拥有的内存地址空间相互独立.  

为了保证安全, 一个进程不能直接访问另一个进程的地址空间.  
但是进程之间的信息交换又是必须实现的. 

### 进程通信的类型

- 共享存储器系统
    进程之间通过共享某些数据结构或共享存储区进行通信.  

    - 基于共享数据结构的通信方式:  
        公用数据结构, 如有界缓冲区.  
        仅适用于传递少量数据, 通信效率低.  
    - 基于共享存储区的通信方式:  
        在内存中划出一块共享存储区域, 诸进程通过对该区域的读写交换信息. 先向系统申请获得分区, 通信完成后归还.  

- 管道通信系统
    管道指连接读写进程通信的一个共享文件(pipe文件).  
    管道机制需要以下协调能力: 互斥, 同步, 确定对方是否存在.  

- 消息传递系统
    以格式化的消息(message)为单位, 将通信的数据封装在消息中, 不需要共享的存储区或数据结构. 并利用操作系统的通信命令(原语)进行传递.  
    过程透明化, 降低通信程序设计的复杂性和错误率, 成为当前应用最为广泛的一类进程间通信的机制.  

    - 直接通信方式: 利用OS的发送原语, 直接发给目标进程.  
    - 间接通信方式: 通过共享中间实体(邮箱)进行发送和接收.  

- 客户机-服务器系统
    网络环境下的主流通信实现机制.  

    主要实现方法分3类:  
    - 套接字:  
        一个套接字即一个通信标识类型的数据结构, 包含通信目的的地址, 端口号, 传输层协议等等.  
        既适用于同一计算机内部进程通信(类似管道通信), 也适用于网络中不同计算机间的进程通信.  
    - 远程过程调用和远程方法调用:  
        远程过程(函数)调用 RPC, 是一个通信协议, 用于通过网络连接的系统. 该协议允许本地进程调用远程进程, 对程序员表现为常规的过程调用, 无需额外编程.  


### 消息传递通信的实现方式

**直接消息传递系统**:  

- 直接通信原语  
    - 对称寻址方式:  
        send(receiver, message);  
        receive(sender, message);  
    - 非对称寻址方式:  
        接收进程不需要命名发送进程, 只填表示源进程的参数.  
        receive(id, message);  

- 消息的格式:  
    ...

- 进程的同步方式:  
    ...

- 通信链路:  
    为使发送进程和接收进程之间能进行通信, 必须在两者之间建立一条通信链路. 有两种方式:  
    1. 由发送进程在通信之前用显式的"建立连接"命令(原语)请求系统为之建立一条通信链路, 使用完拆除. 主要用于计算机网络中.  
    2. 无需提出建立链路的请求, 利用发送命令(原语), 系统会自动建立链路. 主要用于单机系统中.  


**信箱通信**:

- 信箱的结构  
    - 信箱头: 存放有关信箱的描述信息.  
    - 信箱体: 由若干个可以存放消息(或消息头)的信箱格组成.  

- 信箱通信原语  
    Send(mailbox, message);     // 将消息发送到指定信箱.  
    Receive(mailbox, message);  // 从指定信箱接收消息.  

- 信箱的类型  
    - 私有邮箱: 用户进程创建的邮箱, 其他进程只能发送到该邮箱, 不能查看. 随进程结束而消失.  
    - 公用邮箱: 操作系统创建, 提供给所有核准进程使用. 既可发送消息到该邮箱, 也可读取发送给自己的消息. 通常在系统运行期间始终存在.  
    - 共享邮箱: 某进程创建, 指定共享的进程后. 拥有者和共享者都可从中取走发送给自己的消息.  

## 线程(Threads)

### 基本概念

线程: 可以理解为轻量级的进程.  

在 OS 中引入进程大的目的是使多个程序能并发执行, 以提高资源利用率和系统吞吐量.  
再引入线程是为了减少程序在并发执行时所付出的时空开销, 使 OS 有更好的并发性.  
传统的进程概念和设计方法使进程的创建, 调度, 分派都需要花费较大的时间和空间开销.  

在引入线程后:  
    线程成为调度和分派的基本单位, 是能独立运行的基本单位.  
    进程之间可以并发, 一个进程的多个线程之间也可并发.  
    进程只作为**除CPU之外的系统资源的分配单位**.  

如同进程, 线程也有线程控制块TCB.  
在同一进程中, 线程的切换不会引起进程的切换; 如果切换的线程属于不同的进程, 则应先切换到对应的进程.  

### 线程的实现

- 内核支持线程(内核级线程, KST)  
    内核级线程的管理工作由操作系统内核完成. 线程调度, 切换等工作由内核负责, 内核级线程的切换需要在核心态下完成.  

- 用户级线程(ULT)  
    用户级线程无需内核的支持, 所有的线程管理工作由应用程序负责.  
    对于设置了用户级线程的系统, 其调度仍是以进程为单位.  

一些操作系统只实现内核支持线程, 一些只实现用户级线程, 还有一些同时实现了这两种类型的线程.  

在同时支持内核级线程和用户级线程的系统中, 可采用二者组合的方式: 将n个用户级线程映射到m个内核级线程上(n >= m).  
    用户级线程和内核级线程的连接方式: 多对一模型, 一对一模型, 多对多模型.  
**内核级线程才是处理机分配的单位**.  


# 处理机调度


处理机调度: 处理机调度即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行, 以实现进程的并发执行.  

- 层次:  
    - 高级调度:  
        又称长程调度或作业调度, 它的调度对象是作业.  
        其主要功能是根据某种算法, 决定将外存上处于后备队列中的哪几个作业调入内存, 为它们创建进程, 分配必要的资源, 并将它们放入就绪队列.  
        高级调度主要用于多道批处理系统, 分时和实时系统中不设置高级调度.  

    - 低级调度:  
        又称进程调度或短程调度, 调度对象为进程(或内核级线程).  
        其主要功能是根据某种算法, 决定就绪队列中的哪几个进程应获得处理机, 并由分配程序将处理机分配给被选中的进程.  
        进程调度是最基本的一种调度, 在多道批处理, 分时, 实时中都必须配置这级调度.  

    - 中级调度:  
        又称内存调度.  
        引入的目的是, 提高内存利用率和系统吞吐量. 把暂时不能运行的进程调至外存等待, 此时进程的状态称为就绪驻外存状态(或挂起状态).  
        由中级调度决定就绪驻外存的进程被调入内存.  

-  目标:  
    - 资源利用率:  
        $CPU的利用率 = \frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间} $

    - 公平性:  
        各进程都获得合理的 CPU 时间, 不发生进程饥饿现象.  
    
    ...

周转时间: 作业被提交给系统到作业完成的时间.  
带权周转时间: 权即周转时间与系统为它提供服务的时间之比.  
系统吞吐量: 单位时间内系统完成的作业数.  

## 作业与作业调度

### 批处理系统的作业

- 作业(Job)  
    作业是一个比程序更广泛的概念, 它不仅包含了通常的程序和数据, 而且还应该配有一份作业说明书. 在批处理系统中, 是以作业为基本单位从外存调入内存的.  
- 作业步(Job Step)  
    通常在作业运行期间, 每个作业都必须经过若干相对独立, 又相互关联的顺序加工步骤. 每个加工步骤称为一个作业步.  

- 作业控制块  
    为管理和调度作业, 为每个作业设置一个作业控制块 JCB. 

- 三个阶段与三个状态  
    收容阶段(后备状态), 运行阶段(运行状态), 完成阶段(完成状态).  

### 调度算法

1. 先来先服务(FCFS)调度算法  
    可用于作业或进程调度. 在单处理系统中已很少作为主调度算法, 但经常将其与其它调度算法结合使用.  
2. 短作业优先(SJF)调度算法  
    以作业的运行时间长短来计算优先级, 越短优先级越高.  
    但作业运行时间难以预测, 对长作业非常不利, 人机无法交互, 未考虑作业紧迫程度.  

3. 优先级调度算法(PSA)  
    基于作业的紧迫程度, 由外部赋予作业相应的优先级, 根据该优先级进行调度.  
4. 高响应比优先调度算法(HRRN)  
    既考虑作业的等待时间, 又考虑作业运行时间.  
    $$优先权 ＝ \frac{等待时间＋要求服务时间}{要求服务时间} ＝ \frac{响应时间}{要求服务时间}$$  

## 进程调度

### 进程调度的任务, 机制, 方式

- 任务:  
    保存处理机的现场信息, 按某种算法选取进程, 把处理机分配给进程.  
- 机制: 为实现进程调度, 进程调度机制应有如下三个基本部分:  
    排队器: 将就绪进程按一定策略排成一个或多个队列.  
    分派器: 依据进程调度程序选定进程, 进行上下文切换, 并分配处理机.
    上下文切换器: 保存原进程的环境, 载入新进程.  
- 方式:  
    - 非抢占方式:  
        只允许进程自动放弃处理机, 一直运行到进程结束或阻塞.  
    - 抢占方式:  
        当进程正在运行时, 如果有更重要或紧急的进程需要处理机, 会让出处理机.  

### 调度算法

**轮转(RR)调度算法**:  

- 原理:  
    按就绪队列(FCFS策略), 每个进程轮流执行一个时间片.  
- 切换时机:  
    进程完成或时间片结束.  
- 时间片大小:  
    时间片小, 会增加系统切换进程的开销; 太长则影响交互需求.  
    一般略大于一次典型的交互所需时间.  


**优先级调度算法**:  

- 算法类型  
    - 非抢占式: 出现更高优先级进程时, 应先执行当前进程.  
    - 抢占式: 出现更高优先级进程时, 会调度最高优先级进程.  

- 优先级类型  
    - 静态优先级:  
        在创建进程时确定且不会改变, 用整数(优先数)表示.
        确定优先级大小的依据: 进程类型, 进程对资源的需求, 用户要求.  
    - 动态优先级:  
        创建进程时赋予一个优先级, 但会改变. 如随等待时间增长, 提高优先级.  
        这样能防止低初始优先级的进程一直不被调度.  


**多队列调度算法**:  

建立多个就绪队列, 不同的就绪队列采用不同的调度算法.  


**多级反馈队列调度算法**:  

- 设置多个就绪队列, 优先级从高到低, 时间片从小到大(逐级翻倍).  
- 每个队都采用 FCFS 算法, 在一个时间片内未完成则放入下一队列的末尾. 最后一个队列采用 RR 方式运行.  
- 当第 i 队列的进程正被执行时又有新进程进入更高优先级队列, 先就其放回 i 队末尾, 重新执行高优先级进程.   

此算法能较好地满足各类型用户的需求. 是目前公认的一种较好的进程调度算法.   

**基于公平原则的调度算法**:  

- 保证调度算法:  
    如果在系统中有 n 个相同类型的进程同时运行, 每个进程都能获得相同的处理机时间 1/n.  

- 公平分享调度算法:  
    不同的用户的进程数目可能不同, 如果要对各用户公平, 应给予各用户相同的时间片轮流执行. 或者一个用户的处理机时间是另一个的两倍...


## 实时调度

- 实现实时调度的基本条件:  
    - 必要的信息: 就绪时间, 开始截止时间和完成截止时间, 处理时间, 资源要求, 优先级.  
    - 系统处理能力强.  
    - 采用抢占式调度机制.  
    - 具有快速切换机制.  

- 分类:  
    - 非抢占式调度算法: 可用于要求不太严格的实时控制系统中.  
    - 非抢占式优先调度算法: 添加了优先级别, 可用于有一定要求的实时控制系统.  
    
    - 基于时钟中断的抢占式优先级调度算法: 时钟中断后进行抢占. 可用于大多数实时系统.  
    - 立即抢占的优先级调度算法: 当进程不处于临界区时可以立即抢占.  


### 最早截止时间优先

顾名思义,任务的截止时间越早优先级越高.  

抢占式和非抢占式都可以用.  

当截止时间相同时, 不进行切换以减小系统开销.


### 最低松弛度优先(LLF)算法

松弛度: 截止时间 - 需要的运行时间 - 当前时间.  
松弛度越低, 优先级越高.  
主要用于可抢占调度方式中.  

- 优先级倒置:  
    低优先级进程(P3)进入临界区, 此时高优先级进程(P2)抢占处理机, 之后更高优先级进程(P1)抢占处理机, 而资源被最低优先级进程占用, 只能将处理机还给P2. 之后是P3, 最后P1.

- 解决方法:  
    - 进入临界区的进程不允许被抢占. 但临界区较长时, 仍需等待很久.  
    - 动态优先级继承, 高优先级进程可将其优先级继承给占用资源的低优先级进程, 直到退出临界区.  


## 死锁概述

### 资源问题

- 可重用性资源:  
    可重复使用, 但不允许共享. 其数目相对固定.  
- 可消耗性资源:  
    又称临时性资源, 由进程动态地创建和消耗

- 可抢占性资源:  
    某进程在获得这类资源后, 该资源可以再被其他进程或系统抢占.  
- 不可抢占性资源:  
    一旦系统把某资源分配给该进程后, 就不能将它强行收回, 只能在进程用完后自行释放. 如磁带, 打印机等.  

### 死锁

- 竞争不可抢占性资源引起死锁:  
    两个进程争抢两个都需要的资源...  
- 竞争可消耗资源引起死锁:  
  
- 进程推进顺序不当引起死锁:  
  

- 死锁的定义:  
    如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件, 那么该组进程是死锁的.  

- 产生死锁的必要条件  
    - 互斥条件
    - 请求和保持条件
    - 不可抢占条件
    - 循环等待条件

- 处理死锁的方法
    - 预防死锁  
        通过设置某些限制条件, 破坏产生死锁的必要条件.  
    - 避免死锁  
        在资源的动态分配过程中, 用某种方法防止系统进入不安全状态, 避免死锁.  
    - 检测死锁
    - 解除死锁


## 预防死锁

通过设置某些限制条件, 破坏产生死锁的必要条件.  

- 破坏互斥条件

操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。  
但并不是所有资源都可以改造. 并且为了系统安全, 很多地方还必须保护互斥性.  
所以主要是破坏后三个条件.  


- 破坏"请求和保持"条件

当一个进程请求资源时, 它不能持有不可抢占资源. 有两种实现协议:  

1. 所有进程在开始运行之前, 必须一次性地申请其所需的全部资源.  
    其简单, 易行且安全. 但资源浪费严重, 且会使进程饥饿.  

2. 进程运行时先释放已有资源, 再申请还需要的资源.  


- 破坏"不可抢占"条件

当一个已经保持了某些不可抢占资源的进程, 提出新的资源请求而得不到满足时, 它必须释放已经保持的所有资源.  

该方法实现比较复杂, 且需要付出很大的代价.  


- 破坏"循环等待"条件

对系统所有资源类型进行线性排序, 并赋予不同的序号.  
每个进程必须按序号递增的顺序请求资源.  
当进程运行时需要一个编号低的资源时, 它必须先释放编号在其之后的所有资源.  

采用这种策略时, 资源的序号十分重要. 一般输入设备序号较低, 输出设备序号较高.  



## 避免死锁

在资源的动态分配过程中, 用某种方法防止系统进入不安全状态, 避免死锁.  

