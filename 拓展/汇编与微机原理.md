
# 前言

【学习汇编主要是：学习汇编的编程思想，掌握机器运行的思维】

汇编语言是直接在硬件上工作的编程语言, 其与计算机硬件强相关, 首先要了解硬件系统的结构, 才能有效的应用汇编语言对其编程.  

计算机能够识别的只有 0 和 1 的数字信号, 不同的0, 1序列对应着不同的操作(指令), 但0与1的序列不是人类所能够进行记忆的.  
于是使用助记符来代替0, 1序列. 由此有了汇编语言来代替机器指令, 其是一一对应的.  

汇编语言由3类组成:  
- 汇编指令, 机器码的助记符.  
- 伪指令, 由编译器执行.  
- 其他符号, 由编译器识别.  


# 处理器结构

CPU = 运算器 + 控制器 + 【寄存器】，器件之间通过总线相连.  

## 寄存器

8086 CPU有14个寄存器，名称分别为：  
AX，BX，CX，DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW.  

1. 通用寄存器:  
	- IA-32处理器有8个32位寄存器, 在16位寄存器前加16位的扩展, 形成EAX, EBX...  
	- AX, BX, CX, DX通常用来存放一般性数据, 被称为通用寄存器.  
	- 8086上一代CPU中的寄存器都是8位(16位)的，为了保证兼容性.  
		这四个寄存器都是可以分为2个独立的8位(16位)寄存器使用, 高8位H和低8位L.  
		扩展的高16位似乎不能独立使用.  
		AX = AH + AL, BX = BH + BL, CX = CH + CL, DX = DH + DL.  

	ESI: 源变址寄存器(Source Index).  
	EDI: 目的变址寄存器(Destination Index).  
	EBP: 基址指针(Base Pointer).  
	ESP: 堆栈指针(Stack Pointer).  

通用寄存器的一般用途:  

| 通用寄存器 |                   一般用途                    |
|:----------:|:---------------------------------------------:|
|    EAX     | 累加器, 使用频率最高, 用于运算与传递外设信息. |
|    EBX     |       基址寄存器, 常用于存放存储器地址.       |
|    ECX     |      计数器, 作为循环操作等指令的计数器.      |
|    EDX     |      数据寄存器, 存放数据, 外设端口地址.      |


2. 标志寄存器:  
	标志(Flag), 用于反映指令执行结果或控制指令执行形式.  
	许多指令的执行要利用某些标志, 或对其进行更改.  
	32位的标志寄存器: EFLAGS.  

![标志寄存器.png](https://www.freeimg.cn/i/2024/01/13/65a223b7f045e.png)

3. 专用寄存器:  
	1. 指令指针:  
		程序由指令组成, 指令存放与主存储器(内存)中, 需要记录其位置(IP寄存器).  
		指令地址储存于程序计数器PC中.  
	2. 段寄存器:  
		对应用程序来说, 主要有三类段(Segment): 代码段(CS), 数据段(DS), 堆栈段(SS), 附加段(ES, 用于存放数据).  
		为了表明段在主存中的位置, 设有数个(6)16位段寄存器.  
	3. 其他寄存器:  
		如 与浮点数处理相关的寄存器, 多媒体相关的MMX寄存器...  



## 存储器组织

- 物理地址:  
	物理存储器以字节为基本储存单位.  
	每个储存单元有唯一的地址, 也称物理地址. 从0递增.  

- 逻辑地址:  
	进行程序设计时采用逻辑地址, 由**段(基)地址**和**偏移地址**组成.  
	段地址为段在内存中的起始地址.  
	以段地址为起点, 段内的地址可以用距离起点的位移量表示, 即偏移地址.  
	段: 相同, 相关的内容放置于连续的内存空间中. 如 程序段, 数据段...  

- 地址转换:  
	每个段最大为64KB, 段地址为16的整数倍, 且只保存高于最后4位的地址. 因此:  
	**物理地址 = 段地址 \* 16 + 偏移地址**.  
	段地址与偏移地址都是16位, 以 2进制 表示时, 乘以16即 左移4位.  


## 数据寻址方式

指令由**操作码**和**操作数**两部分组成.  
操作数可以有多个数. 
当操作数有两个时(结果, 源数据), 左边的称为目的操作数, 右边为源操作数.  

想要操作数据, 需要先知道它的地址, 才能找到它, 进行操作.  
除外设数据外的数据寻址方式有:  
- 立即寻址(用常量表示的具体数据).  
- 寄存器寻址(数据存放于某个寄存器中).  
- 存储器寻址(以存储器地址代表的数据).  


**立即寻址**:  

指令需要的操作数紧跟在操作码(指令)后, 作为指令机器代码的一部分.  
其一般为常量, 只用于**源操作数**.  
如: `mov al, 23H`, 将常量23H移入al寄存器.  

**寄存器寻址**:  

指令的操作数存放在寄存器中. 使用寄存器名表示其保存的数据.  
如, `mov bx, ax`, 将ax寄存器的数据放入bx.  


### 存储器寻址

当数据放在主存中时, 其有多种寻址方式. 数据一般会存放在指定的数据段中.  

有效地址 = 基址 + 变址 * 比例 + 位移量.  
- 16位存储器:  
	没有"比例", 或者说"比例"固定为 1.  
	基址寄存器为 BX或BP; 变址寄存器为SI或DI.  
	位移量为8或16位有符号数.  
- 32位储存器:  
	基址寄存器: 任何8个32位通用寄存器之一.  
	变址寄存器: 除ESP之外的通用寄存器.  
	比例: 可以为1, 2, 4, 8.  
	位移量: 8或32位有符号值.  

1. 直接寻址:  
	有效地址只有位移量部分, 且直接包含在指令代码中.  
```nasm
x byte 12H
y word 1234H
z dword 12345678H

mov al, x
mov bx, y
mov cx, z
```

2. 寄存器间接寻址:  
	有效地址存放在寄存器中, 即寄存器存放的不是数, 而是数的地址.  
	将寄存器用方括号 `[]`, 表示其中的是地址.  
```nasm
x dword 12345678H
y dword ?   ; ? 表示其值不确定, 无初始值

mov ebx, offset x  ; 获取 x 的偏移量(地址)
mov esi, offset y
mov edx, [ebx]     ; 将 x 放入 edx
mov [esi], edx     ; 将 edx 的值写到 y
```

3. 寄存器相对寻址:  
	有效地址为寄存器内容与位移量之和.  
	一般用于操作数组元素.  
```nasm
a dword 20240101H
x dword 12345678H, 87654321H
b dword 13572468H

mov ebx, offset x  ; 获取 x 的地址
mov eax, [ebx + 4] ; dword: 4个字节, 所以下一个为 首地址+4. 相当于 x[1]
mov ecx, [ebx - 4] ; a
mov esi, 8
mov edx, x[esi]    ; x代表首地址, []内为偏移量, 8即为变量b
```

4. 变址寻址:  
	有效地址为 基址寄存器 加 变址寄存器, 也可以再加位移量.  
	适用于二维数组.  
```nasm
a byte 12H, 34H, 56H, 78H

mov ebx, offset a
mov ecx, 4    ; 设置循环次数
mov esi, 0

next:   ; 循环入口
	mov eax, [ebx + esi]  ; 等效于 mov eax, [ebx][esi]
	add esi, 1   ; byte 为 1字节
loop next    ; 循环
```

5. 带比例的变址寻址:  
	`mov eax, [ebx + esi * 4 + 80H]`.  


# 常用指令

## 数据传送

- 传送指令: ＭＯＶ.  
- 交换指令: ＸＣＨＡＮＧ.  
- 堆栈操作指令: ＰＵＳＨ, ＰＯＰ.  
- 换码指令: ＸＬＡＴ.  
- 标志传送指令: ＣＬＣ，ＳＴＣ，ＣＭＣ，ＣＬＤ，ＳＴＤ，ＣＬＩ，ＳＴＩ.  
- 地址传送指令: ＬＥＡ.  

<br>

- ＭＯＶ:  
	格式: `mov dest, src`.  
	功能: dest=src.  
	寻址方式: 支持8种寻址方式.  
	标志位影响: 没有.  
> 操作数类型需要一致(内存大小), 类型明确, 或进行强制类型转换.  
> 双操作数不允许同时是内存单元.  
> 能对专用寄存器进行操作的指令有限.  

![mov指令操作.png](https://www.freeimg.cn/i/2024/01/13/65a223b7c0ba1.png)

- ＸＣＨＧ:  
	格式: `XCHG reg reg/mem`.  
	功能: reg $\leftrightarrow$ reg/mem.  
	寻址方式: 通用寄存器之间, 通用寄存器与主存.  
	标志位影响: 没有.  

- 堆栈操作:  
	堆栈建立在主存中, 栈顶位置由 ESP 确定, 栈底即 ESP 初始值.  
	`push src`: 将数据压入栈顶.  
	`pop dest`: 将栈顶数据弹出.  
	一般用于函数的寄存器数据保护. 先将函数需要用到的寄存器的数据压入栈中, 结束时再逆序弹出.  

- 换码指令:  
	格式: `XLAT`.  
	功能: AL <- \[BX + AL].  
	将缓冲区该地址的数据移入AL, 其操作数隐含在 AX, BX中. 默认缓冲区在DS. 如果在其他段, 需要指明.  
	XLAT指令用于将一种代码转换为另一种代码.  
	例如, 将键盘位置转换为ASCII码, 将数字转换为7段显示码.  
	转换的数据与地址是一一对应的, 所以能方便地进行转换.  

- 标志传送指令:  
	IA-32处理器可以直接修改CF, DF, IF标志状态的标志位操作指令.  

| 指令 | 功能                    |
| ---- | ----------------------- |
| CLC  | 复位进位标志: CF -> 0   |
| STC  | 置位进位标志: CF -> 1   |
| CMC  | 求反进位标志: CF -> CF' |
| CLD  | 复位方向标志: DF -> 0   |
| STD  | 置位方向标志: DF -> 1   |
| CLI  | 复位中断标志: IF -> 0   |
| STI     | 置位中断标志: IF -> 1                        |
> 方向标志DF: 0, 串操作后地址增大; 1, 串操作后地址减小.  
> 中断标志IF: 0, 禁止可屏蔽中断; 1, 允许可屏蔽中断.  

- 地址传送指令:  
	格式: `LEA r16/r32, mem`.  
	功能: r16/r32 <- mem的有效地址EA.  
	寻址方式: r16/r32寄存器寻址, mem存储器寻址.  

	其作用等同于 MASM 的地址操作符 OFFSET.  
	LET 是在指令执行时计算出偏移地址, 而OFFSET是在汇编阶段取得变量的偏移地址.  
	OFFSET速度更快, 但对于无法在汇编阶段确定的地址, 就只能使用LEA.  


## 算术运算

算术运算会对标志位有影响, 或者说: **标志状态是运算结果的一部分**.  
标志通常会成为各种条件跳转指令的判断依据.  

### 相关标志

- 进位标志ＣＦ:  
	进位标志是为**无符号整数**运算设计的.  
	进(借)位标志表示二进制数据最高位的进位或借位.  
	
- 溢出标志ＯＦ:  
	溢出表示是为**有符号整数**运算设计的.  
	在加减法中表示运算的溢出情况.  

- 其他:  
	- 零标志ＺＦ: 表示运算结果是/否(1/0)为零.  
	- 符号标志ＳＦ: 表示运算结果的正/负(0/1), 其与结果最高位保持一致.  
	- 奇偶标志ＰＦ: 表示最低字节中"1"的个数为奇数/偶数(0/1).  
	- 调整标志ＡＦ: 表示运算最低半字节有/无进(借)位.  


### 加法指令

- ADD:  
	`ADD dest, src`.  
	功能: dest = dest + src.  
	会影响 上面6个标志位.  

- ADC:  
	带进位加法指令.  
	`ADC dest, src`.  
	功能: dest = dest + src + CF.  
	用于与ADD结合实现多精度数的加法.  

- INC:  
	自增指令, 使操作数加一, 再放回原处.  
	`INC reg/mem`.  
	功能: reg/mem++.  
	其不影响进位标志 CF.  


### 减法指令


- SUB(subtract):  
	`SUB dest, src`.  
	功能: dest = dest - src.  
	
- SBB:  
	带进位减法指令.  
	`SBB dest, src`.  
	功能: dest = dest - src - CF.  
	也是用于与SUB结合实现多精度的减法.  

- DEC(decrement):  
	减量指令, 使操作数减一.  
	`DEC reg/mem`.  
	功能: reg/mem--.  
	同样不影响进位标志 CF.  

- NEG(negative):  
	 求补指令.  
	 `NEG reg/mem`.  
	 功能: reg/mem = 0 - reg/mem.  

- CMP(complete):  
	比较指令, 两数相减, 但结果不返回, 进行两个数的大小比较.  
	`CMP dest, src`.  
	通过标志位 ZF 可以知道比较结果.  


### 乘法指令

| 指令类型 | 指令 | 功能 |
| ---- | ---- | ---- |
| 无符号数乘法 | MUL src | AX = AL \* r8/m8<br>DX.AX = AX \* r16/m16<br>EDX.EAX = EAX \* r32/m32 |
| 有符号数乘法 | IMUL src | 同上 |
| 双操作数乘法 | IMUL dest, src | dest = dest \* src |
| 三操作数乘法 | IMUL dest, src, imm | dest = dest \* src \* imm |
> 单个操作数时, 另一个数隐含在 AL/AX/EAX 中, 取决于数据位数(8/16/32).  
> 其乘积表示结果的高位和低位放置的寄存器(AX/DX.AX/EDX.EAX).  
> 三个操作数时必须有一个是立即数.  

对标志位的影响:  
- 单操作数:  
	如果乘积的高位是低位的**符号位扩展**, 即高位不含有效数值, 则OF = CF = 0; 否则, OF = CF = 1.  
	但乘法指令对其他标志位没有定义, 即 会产生"无法预测的影响".  
- 双/三:  
	操作数长度相同, 所以有可能会溢出.  
	溢出时: CF = OF = 1, 否则: CF = OF = 0.  

### 除法指令


无符号数除法: DIV src.  
有符号数除法: IDIV src.  

AL = AX $\div$ r8/m8 的商, AH存放余数.  
同样, 被除数如果有更高的位数会放在 AX/DX.AX/EDX.EAX  

- 标志位:  
	除法对状态标志没有定义, 但当**除数为零**或**商超过范围**, 会发生除法溢出, 处理器将产生编号为0的内部中断.  


### 零位扩展与符号位扩展

当两个操作数位数不一致时, 需要先将较短的操作数扩展至长度一致.  
如 将8位扩展为16位, 将16位扩展为32位.  

- 无符号数:  
	对于无符号数, 只要在前面 加0 就可进行位数扩展, 即**零位扩展**.  
	指令: `MOVZX r16, r8/m8`...  

- 有符号数:  
	对于有符号数, 需要进行符号扩展. 正数前面加0, 负数加1.  
	指令: `MOVSX r16, r8/m8`...  


## 位运算


### 逻辑运算指令

| 指令 | 功能     |
| ---- | -------- |
| AND dest, src  | 逻辑与, dest = dest & src   |
| OR dest, src   | 逻辑或, dest = dest \| src   |
| NOT reg/mem  | 逻辑非, reg/mem = - reg/mem   |
| XOR dest, src  | 逻辑异或, dest = dest ⊕ src |
| TEST dest, src     | 测试(按位与), 不返回结果.          |
> NOT指令不影响标志位.  
> 其他指令会使 CF = OF = 0, 根据结果设置SF, ZF, PF.  


### 移位指令

- 逻辑移位指令:  
	逻辑左移: SHL.  
	逻辑右移: SHR.  
- 算术移位指令:  
	算术左移: SAL.  
	算术右移: SAR.  

> 操作数有两个. 第一个可以是寄存器(8/16)或存储单元; 后一个为移动位数, 可以是立即数或cl寄存器.  
> 逻辑左/右移会将移出的位放入CF标志中, 最低/高位补0.  
> 算术左移与逻辑左移一致; 算术右移最高位不变, 移出的同样放入CF.  

- 循环移位指令:  
	循环移位会将移出的位补充至空缺位.  
	- 不带进位:  
		循环左移: ROL.  
		循环右移: ROR.  
	- 带进位:  
		循环左移: RCL.  
		循环右移: RCR.  
	
	带进位会将进位CF也视为数据的一部分(最高位), 将从CF移出后的数据放入最低位.  
	不带进位即进位CF不在循环内, 但也会将移出的数据放入CF.  


# 汇编程序设计

汇编源程序文件为 .asm 文件.  
每一行即为一条语句, 不区分大小写.  
需要利用MASM进行汇编, 连接等生成可执行文件.  
16位的汇编程序要使用DOSBox模拟器才能执行, 32位可以直接运行.  
将MASM加入环境变量后可以通过cmd命令进行构建:  
`build(32) fileName` 进行汇编和链接成exe文件.  
> 文件名不用加后缀.  

## 语句

**执行性语句格式**:  
标号: 硬指令助记符 操作数, 操作数.. ; 注释  
> 标号可以没有.  

**注释**:  
汇编中以 ";" 表示注释, 其之后的这一行内容被视为注释.  


## 程序框架

16位源程序框架:  
```nasm
.model small
.8086
.stack
; 堆栈段, 可以没有
.data
; 数据段, 可以没有
.code
.startup
; 程序段, 必须要有
end
```

16位示例:  
```nasm
include io16.inc    ; 导入"包含文件"(头文件)
.data
; 定义字节变量(字符串), 后面为回车换行字符结束符的ASCII码.
msg byte 'Hello, Assembly!',13,10,0
.code
start:
mov ax, @data   ; 将数据段地址移入ax
mov ds, ax      ; 再将其移入ds(数据段寄存器)
mov ax, offset msg  ; 将字符串变量的首地址移入ax
call dispmsg    ; 内置函数, 显示ax地址的字符串
exit 0          ; 退出, 返回0
end start       ; 结束汇编, 汇编是从start到end start
```

32位示例:  
```nasm
include io32.inc
.data
	msg byte 'Hello, Assembly!',13,10,0
.code
start:
	mov eax, offset msg
	call dispmsg
	exit 0
end start
```

- 子程序调用:  
	汇编中通过 `call funcName` 的方式调用子程序.  
	
- dispmsg:  
	包含在 io32.inc中.  
	入口参数: EAX=字符串地址.  
	功能: 显示字符串, 以 0 结尾.  

| 子程序名 | 参数 | 功能 |
| ---- | ---- | ---- |
| dispmsg |  | 显示字符串(以0结尾) |
| dispc |  | 显示一个字符 |
| dispcrlf |  | 回车换行 |
| disprd |  | 显示8个32位通用寄存器内容 |
| disrf |  | 显示6个状态标志的状态 |
| disphd |  | 以十六进制形式显示8位数据 |
| dispuid |  | 显示无符号十进制整数 |
| dispsid |  | 显示有符号十进制整数 |

| 子程序名 | 参数 | 功能                       |
| -------- | ---- | -------------------------- |
| readmsg  |      | 输入字符串(回车结束)       |
| readc    |      | 输入字符                   |
| readhd   |      | 输入8位十六进制数          |
| readuid  |      | 输入无符号十进制数(< 2^32) |
| readsid         |      | 输入有符号十进制数(-2^31 ～ 2^31 - 1)                           |


## 变量


- 数:  
	不同进制的数以不同的后缀表示:  
	二(b), 八(o), 十(d), 十六(h), 十进制可以不加.  
- 字符:  
	字符(串), 数值为对应ASCII码.  
- 符号常量:  
	符号定义伪指令: EQU, =. 例: `pi equ/= 3`.  
	相当于c中的 "#define".  

<br>  

- 变量类型:  
	定义变量时, 汇编中没有整数, 浮点字符等的区分.  
	只有不同大小(位数)的变量.  
	- DB(byte): 1字节变量(8位).  
	- DW(word): 2字节变量(一个字).  
	- DD(dword): 4字节变量(双字).  
	- DF(fword): 6字节变量.  
	- DQ(qword): 8字节变量.  
	- DT(tword): 10字节变量.  
	一般用 1, 2, 4字节的变量.  
	形式: `变量名 变量类型 变量值1, 变量值2...`  
	跟多个值时, 可以视为数组, 数组偏移量单位为字节.  
	变量值为 "?" 时, 表示不确定, 初始值为0.  

- 定义多个相同值:  
	`bvar db 10 dup(0)`.  
	定义 10 个 0.  
	dup前面的数为值的个数, 括号内为值的大小.  

> 在存放多字变量时, 低位字节放在低地址.  

| 地址操作符    | 说明                       |
| ------------- | -------------------------- |
| \[]           | 按存储器地址取操作数       |
| \$            | 返回当前偏移地址           |
| offset 变量名 | 返回变量名所在段的偏移地址 |
| seg 变量名              | 返回段基地址                           |
 
| 类型操作符        | 说明                                 |
| ----------------- | ------------------------------------ |
| 类型名 ptr 变量名 | 将变量按指定的类型使用(强制类型转换) |
| type 变量名       | 返回其元素占用空间的字节数              |
| lengthof 变量名   | 返回变量的数据项数(数组元素个数)     |
| sizeof 变量名                  | 返回整个变量占用的字节数                                     |


## 分支程序结构


通过条件判断来进入(跳转)不同的分支.  

### 跳转指令

- ＪＭＰ:  
	无条件跳转指令, 相当于"goto".  
	`jmp label`: 跳转到指定标号.  
	`jmp r/m`: 跳转到指定地址.  

- ＪＣＣ:  
	条件转移指令. cc代表各种条件, 有许多种不同的条件转移指令.  
单个标志位作为判断条件:  

| **指令** | 条件 | **反指令** | 条件 | 标志 |
| ---- | ---- | ---- | ---- | ---- |
| **JZ/JE** | ZF = 1 | **JNZ/JNE** | ZF = 0 | 结果为零 |
| **JS** | SF = 1 | **JNS** | SF = 0 | 符号为负/正 |
| **JP/JPE** | PF = 1 | **JNP/JPO** | PF = 0 | 有偶/奇数个"1" |
| **JO** | OF = 1 | **JNO** | OF = 0 | 溢出 |
| **JC** | CF = 1 | **JNC** | CF = 0 | 进位 |

| 无符号数比较指令 | 条件              |    说明    | 有符号数比较指令 | 条件               |
|:----------------:| ----------------- |:----------:|:----------------:| ------------------ |
|        JB        | CF = 1            | 结果为小于 |        JL        | SF ! = OF          |
|        JA        | CF = 0 and ZF = 0 | 结果为大于 |        JG        | SF = OF and ZF = 0 |
|       JBE        | CF = 1 or ZF = 1  |  小于等于  |       JLE        | SF != OF or ZF = 1 |
|       JAE        | CF = 0            |  大于等于  |       JGE        | SF = OF            |


### 单分支结构

![单分支结构.png](https://www.freeimg.cn/i/2024/01/13/65a223b7d66ce.png)

示例:  
- 奇校验:  
```nasm
; 奇校验程序
include io32.inc

.code
start:
	call readc  ; 键盘读取字符, (地址)放入al
	call dispcrlf  ; 回车换行
	call dispbb ; 二进制显示
	call dispcrlf
	test al, 0ffh  ; 与运算, 不返回结果, 但改变标志位PF
jnp next  ; 奇数个"1", 则跳转
	; 否则, 最高位置 1
	or al, 80h
next:
	call dispbb
	exit 0
end start
```

- 大写字母转小写:  
```nasm
include ioi32.inc
.code
start:
	call readc  ; 读取字符
	cmp al, 'A'
	jb done  ; 小于'A', 跳至"done"
	cmp al, 'Z'
	ja done  ; 大于'Z', 跳至"done"
	; 否则, (ASCII码)加32
	add al, 32
	call dispcrlf  ; 回车换行
	call dispc     ; 显示字符(al)
done:
	exit 0
end start
```


### 双分支结构

![双分支结构.png](https://www.freeimg.cn/i/2024/01/13/65a223ba522d8.png)

示例:  
- 位测试程序:  
```nasm
include io32.inc
.data
msg0 byte 'Not Ready', 13, 10, 0
msg1 byte 'Ready to Go', 13, 10, 0
.code
start:
	call readuid    ; 读入无符号数, 放入EAX
	test eax, 01h   ; D0 = 0 ?
	jz two
	mov eax, offset msg1
	jmp done
two:
	mov eax, offset msg0
done:
	call dispmsg
	exit 0
end start
```

- 显示数据最高位:  
```nasm
include io32.inc
.code
start:
	call readsid  ; 读取有符号数
	mov ebx, eax
	shl ebx, 1  ; 左移1位, 符号位移入CF
	jc two
	mov al, '0'
	jmp done
two:
	mov al, '1'
done:
	call dispc
	exit 0
end start
```


## 循环程序结构


循环结构的三个部分:  
- 循环初始化: 如循环次数, 初始值...  
- 循环体: 重复执行的代码部分, 包括对循环条件的修改.  
- 循环控制: 判断循环条件是否成立, 是否继续循环.  


执行循环体后进行循环条件检测:  
采用 `loop label` 指令实现, 执行时:  
- ECX <- ECX - 1.  
- if ECX≠0, 跳至label, 否则顺序执行.  
![loop循环示意图.png](https://www.freeimg.cn/i/2024/01/13/65a223b7bcbd6.png)

示例:  
- 数组元素求和:  
```nasm
include io32.inc
.data
a dword 23,4,314,57,31,152,89
.code
start:
	mov ecx lengthof a  ; a元素个数放入ecx, 作为循环次数
	xor eax, eax    ; eax清零
	mov esi, 0      ; 数组下标
again:
	add eax, a[esi*4]  ; 元素大小为4字节(dword), 下标*元素大小.  
	inc esi    ; esi++
	loop again
	call dispsid
	exit 0
end start
```

当然, 循环也可以使用Jcc实现, 条件成立时跳转至循环开始或跳出循环...  


## 子程序


子程序: 相当于函数, 汇编中称之为"过程"(和SQL一样...).  

过程定义伪指令:  
```nasm
proc_name PROC
	......  ; 过程体
proc_name ENDP

; 调用过程
call proc_name/proc_address
```

返回值:  
在过程中, 可以通过 `RET (i16)` 返回, 可以有/无参数.  

- 参数传递:  
	1. 寄存器.  
		把参数存于约定的寄存器, 少量数据直接传值, 大量数据传地址.  
		在子程序中使用的其他寄存器需要进行保护.  
	2. 变量.  
		子程序和主程序使用同一个变量名存取数据.  
		如果变量定义和使用不在同一个程序模块中, 需要利用Public、Extren声明.  
	3. 堆栈.  
		主程序将入口参数压入堆栈, 子程序从堆栈中取出参数.  
		出口参数通常不使用堆栈传递.  
		高级语言函数调用时的参数传递也是利用堆栈.  
		堆栈传递是编译程序处理参数传递, 以及汇编与高级语言混合编程时的常规方法.  

实例:  
- 子程序计算 n! (寄存器传递参数):  
```nasm
include io32.inc
.code
start:
main proc
	call readuid  ; eax
	mov ecx, eax  ; 循环次数
	call fact
	call dispuid
	exit 0
main endp

; 入口参数: eax = n
; 出口参数: eax = n!
fact proc
	push ebx  ; 寄存器保护, 入栈

	mov eax, 1  ; 累积结果
	mov bx, 1   ; 乘数
again:
	mul bx  ; eax=eax*bx
	inc bx
	loop again

	pop ebx  ; 寄存器恢复, 出栈
	ret
fact endp
end start
```

- 输入输出n个十进制有符号数(变量传参):  
```nsam
include io32.inc
.data
a dword 256 dup(?)
.code
start:
main proc
	mov ecx, 10
	call readnsid
	mov ecx, 10
	call dispnsid
	exit 0
main endp

; 入口参数: 数组a, cx表示数组大小
; 出口参数: 数组变量a
readnsid proc
	push eax
	push esi
	mov esi, 0
next:
	call readsid
	mov a[esi], eax
	add esi, 4
	loop next
	pop esi
	pop eax
	ret
readnsid endp

; 入口参数: 数组a, eax表示数组大小
dispnsid proc
	push eax
	push esi
	mov esi, 0
next:
	call dispsid
	mov al, ''
	call dispc
	add esi, 4
	loop next
	call dispcrlf
	pop esi
	pop eax
	ret
dispnsid endp

end start
```

- 计算有符号数的平均值(堆栈传参):  
```nasm
include io32.inc
.data
array dword 675, 245, -33, 192, 255, 0, 9, -56, 128
.code
start:
main proc
	; 压入数字长度和地址
	push lengthof array
	push offset array
	call average
	call dispsid
	exit 0
main endp

; 入口参数: 数组元素个数与数组地址
; 出口参数: EAX(平均值)
average proc
	push ebx
	push ecx
	push edx

	; esp为堆栈的指针
	mov ebx, [esp+16]  ; +16, 指向数组地址的开始, (3+自身)*4字节
	mov ecx, [esp+20]  ; 数组大小
	xor eax, eax
	xor edx, edx
next: add eax, [ebx+edx*4]
	inc edx
	cmp edx, ecx
	jb next  ; edx < ecx
	cdq      ; eax符号扩展到edx
	idiv ecx  ; edx.eax/ecx
	pop edx
	pop ecx
	pop ebx
	ret 8    ; esp += 8, 去除传入的参数
average endc
end start
```


# 内存


8086有20根地址线, 寻址能力为 2^20 = 1MB.  
寄存器储存的地址为16位, 将最高的4位放在各个段寄存器中.  
实际的地址为: 段寄存器 \* 16 + 16位地址.  
> 段内地址用16位寄存器存放(64K).  
> 如果用16进制数表示, 段寄存器的值左移一位即可.  

......
# I/O接口


I/O接口电路是基本系统与外设实现数据交换的控制电路.  

![IO接口结构.png](https://www.freeimg.cn/i/2024/01/13/65a223b7aaa1c.png)  

- 基本功能:  
	- 数据缓冲: 实现接口双方数据传输速度的匹配.  
	- 信号变换: 把信号相互转换为适合对方的形式.  
- 软件编程:  
	- 接口芯片具有**可编程性**.  
	- **控制字**: 接口芯片中的控制数据, 可以选择工作方式, 控制数据传输.  
	- 初始化程序: 设置原始工作状态等.  
	- 驱动程序: 外设的工作程序, 操纵I/O接口完成具体工作.  


## I/O端口的编址


- 独立编址方式:  
	I/O端口与存储器分别编址.  
	- 优点: 地址空间独立; 控制和译码电路简单; 专门I/O指令使程序清晰易读.  
	- 缺点: I/O指令没有存储器指令丰富.  
	<span style="color:red">80x86系列计算机采用独立编址</span>.  

- 统一编址方式:  
	I/O端口与存储器统一编址. 存储器地址中靠前的一部分用作I/O.  
	- 优点: 不需要专门的I/O指令; I/O数据存取灵活.  
	- 缺点: 占部分存储器空间; 程序不易阅读.  
	大多数嵌入式微控制器采用统一编址方式, 如ARM, PowerPC.  


## 输入输出指令


- 输入指令 IN:
	`IN AL/AX/EAX, i8/DX`  
	从I/O端口读取数据, 源操作数为I/O地址.  

- 输出指令OUT:  
	`OUT i8/DX AL/AX/EAX`  
	把数据写入到I/O接口, 目的操作数为I/O地址.  

- 串输入指令 INS.  
- 串输出指令 OUTS.  

<span style="color:red">8位I/O地址用直接寻址; 16位I/O地址用间接寻址</span>.  
如, 8位: `out 20h, al`; 16位: `mov dx, 3fch  out dx, ax`.  
32位就将地址放入EAX...  


## 中断


![中断过程](https://www.freeimg.cn/i/2024/01/13/65a223bae8469.png)  

- 中断源: 引起中断的事件或原因  
- 中断源识别方法： 
	- 向量中断：处理器获得中断向量号；一个中断向量号对应一个中断；自动转向中断服务程序.  
	- 中断查询：处理器依次查询中断状态寄存器：某个中断请求状态有效说明其提出请求；转向对应的中断服务程序.  

在执行中断服务程序时再次收到中断请求可以进行**中断嵌套**.  


## 8259A中断控制器


Intel 8259A 是可编程中断控制器PIC.  
用于管理可屏蔽中断.  

![8259A.png](https://www.freeimg.cn/i/2024/01/13/65a223b78a4cf.png)  
- 一片8259A可以管理8级中断, 可扩展至64级.  
- 每一级都可单独被屏蔽或允许.  
- 在中断响应周期可提供相应的中断向量号.  
- 8259A设计有多种工作方式, 通过编程选择.  

**8259A的寄存器**:  

- 中断请求寄存器IRR:  
	保存8条外界中断请求信号IR0-IR7的请求状态.  
	Di位为1表示IRi引脚有中断请求.  

- 中断服务寄存器ISR:  
	保存正在服务的中断状态.  
	ISRi=1表示中断正在服务中.  

- 中断屏蔽寄存器IMR:  
	IMRi=1表示IRi中断被屏蔽.  

**8259A的编程**:  

- 初始化编程:  
	- 初始化命令字(ICW).  
	- 选择工作方式.  
- 中断操作编程:  
	- 写入操作命令字(OCW).  
	- OCW1: 写入IMR, 控制中断屏蔽.  
	- OCW2: 产生EOI命令, 改变优先权顺序.  
	- OCW3: 控制读取IRR, ISR, IMR和查询字.  

初始化命令字:  
![8259A初始化命令字.png](https://www.freeimg.cn/i/2024/01/13/65a223b7a74bb.png)  
- ICW1: 规定8259的连接方式与中断源请求信号的有效形式.  
- ICW2: 设置中断向量号, 其值即中断向量号.  
- ICW3: 级联命令字.  
- ICW4: 设定中断控制器的工作方式.  

> A_0: 地址线最低位. 为0, 代表读写偶地址端口; 为1, 代表读写奇地址端口.  
> 8259A有两个地址连续的端口.  

操作命令字:  
OCW1-OCW3: ...  

![8259A端口分配.png](https://www.freeimg.cn/i/2024/01/13/65a223b7e3f61.png)
端口:  
![OCW3.png](https://www.freeimg.cn/i/2024/01/13/65a223b8193a2.png)  



## 8253定时器


![8253定时器.png](https://www.freeimg.cn/i/2024/01/13/65a223b7a672f.png)  

- CLK 时钟输入信号:  
	每输入一个时钟信号, 计数器的计数值减一.  
- GATE 门控制信号:  
	控制计数器工作, 不同工作方式下作用不同. 分成电平控制和上升沿控制.  
- OUT 计数器输出信号:  
	计数结束(计数值为0)时, 产生输出信号.  

- A1A0:  
	地址线.  
	00, 读写计数器0; 01, 读写计数器1; 10, 读写计数器2; 11, 写控制字.  

**工作方式**:  

1. 方式0:  
	计数结束产生中断.  
2. 方式1:  
	可编程的单稳态脉冲.  
3. 方式2:  
	分频脉冲发生器.  
4. 方式3:  
	分频方波发生器.  
5. 方式4:  
	软件触发选通脉冲发生器.  
6. 方式5:  
	硬件触发选通脉冲发生器.  

**工作过程**:  

1. 设定工作方式.  
2. 设定计数初值.  

![8253方式控制字.png](https://www.freeimg.cn/i/2024/01/13/65a2344720c2d.png)
- 读写方式:  
	当计数值小于等于 2^8(256) 时, 可以只读写低位(8位计数).  
	大于256(16位计数): 如果低8位全零, 可以只读写高字节.  
	否则应该 先读写低字节, 再读写高字节.  
	00: 将当前计数值保存至输出锁存器.  
- 计数方式:  
	十进制为BCD码计数, 所以计数范围为: 0-9999.  
	二进制计数范围: 0 - 2^16(64k).  

8253有4个I/O端口: 计数器0, 1, 2 和 控制端口.  
将控制字写入控制端口后, 需要在对应的计数器端口写入初始值.  
采用十进制计数时, 初始值应为对应的BCD码, 如 64 的BCD码为 64H.  


**读取计数值**:  

读取计数值前需要先锁存计数值:  
- 向控制端口写入锁存命令(D5D4 = 00).  
- 再读取对应的计数器端口.  
- 16位计数需要读取两次, 先读取的为低8位, 后读取的为高8位.  


## 8255并行接口


并行数据传输:  
以计算机的字长为传输单位(8, 16, 32).  

为实现并行传输, 就需要并行接口的支持.  

![并行接口](https://www.freeimg.cn/i/2024/01/13/65a234df32a1b.png)  

- 8255有 A, B, C 三个8位端口, 都可以指定为输入或输出端口.  
- 8位数据线, 2位地址线.  

C 端口可以分成上下两个4位部分.  

**工作方式**:  

1. 方式0:  
	基本输入输出方式, 不需要应答式的联络信号.  
2. 方式1:  
	选通输入输出方式, 需要借助联络信号进行输入或输出.  
	**只有 A, B 端口可以采用方式1**.  
	需要利用 C端口的引脚作(3/6个)为应答联络信号.  
3. 方式2:  
	双向选通传送方式, **只有端口 A 可以工作于方式2**.  

地址线会成为输入或输出的另一端.  

- I/O地址:  
	00-11 分别为 A, B, C, 控制端口.  

方式控制字:  
![8255方式控制字.png](https://www.freeimg.cn/i/2024/01/13/65a23d474186b.png)  


## 串行通信接口


异步串行通信格式:  
![异步串行通信格式.png](https://www.freeimg.cn/i/2024/01/13/65a241e793e36.png)  

