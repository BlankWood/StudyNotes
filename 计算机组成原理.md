
# 计算机系统概论

## 冯·诺伊曼计算机的特点

- 计算机由运算器、存储器、控制器、输入输出设备五大部件组成.
- 指令和数据以同等地位存放于存储器内, 并可按地址寻访.
- 指令和数据均用二进制数表示.
- 指令由操作码和地址码组成, 操作码用来表示操作的性质, 地址码用来表示操作数在存储器中的位置.
- 指令在存储器内按顺序存放. 通常, 指令是顺序执行的.
- 机器以运算器为中心, 输入输出设备与存储器间的数据传送通过运算器完成.  

典型的冯·诺伊曼计算机是以运算器为中心的. 现代的计算机已转化为以存储器为中心. 


## 计算机的工作步骤

### 计算机组成

计算机分为**主机**和**外设**.  
主机由**主存储器**和**CPU**组成, CPU内有**运算器**和**控制器**.  

- 主存储器(简称主存或内存):  
    包括存储体M、各种逻辑部件及控制电路等.  
    主存的工作方式就是按存储单元的地址号来实现对存储字各位的存(写入)、取(读出).  
    为实现按地址访问(访存)的方式, 需要配置两个寄存器MAR和MDR.  

- MAR(Memory Address Register):  
    存储器地址寄存器, 用来存放欲访问的存储单元的地址.  
    其位数对应存储单元的个数, 2^N(N位).  

- MDR(Memory Data Register):  
    存储器数据寄存器, 用来存放需要存取的数据.  
    其数位与存储字长相等. 字长即存储单元的位数, 8位, 16位, 32位等.  

随着硬件技术的发展, 主存都制成大规模集成电路的芯片, 而将MAR和MDR集成在CPU芯片中.  

- 运算器:  
    运算器最少包括3个寄存器(现代计算机内部往往设有通用寄存器组)和一个算术逻辑单元(ALU).  
    ACC(累加器), MQ(乘商寄存器), X(操作数寄存器).  

- 控制器:  
    控制器是计算机的神经枢纽, 由它指挥各部件自动、协调地工作.  
    完成一条指令分为**取指、分析、执行**3个阶段.  
    控制器由程序计数器(PC)、指令寄存器(IR)、控制单元(CU)组成.  
    - PC, 用来存放当前欲执行指令的地址, 与主存的MAR间有直接通路, 且有自动加 1 的功能, 即可自动形成下一条指令的地址.  
    - IR, 用来存放当前的指令(来自MDR). IR中的操作码(OP(IR))送至CU, 记为OP(IR) -> CU, 用来分析指令. IR中的地址码(Ad(IR))送至MAR, 记作 Ad(IR) -> MAR.  
    - CU, 用来分析当前指令所需完成的操作, 并发出命令序列.  

- I/O:  
    I/O子系统包括各种I/O设备及其相应的接口. 每一种I/O设备都由I/O接口与主机联系. 它接收CU发出的各种控制命令, 并完成相应的操作.  
    如键盘, 打印机等.  

### 指令执行过程

取指:  
将 PC 的内容送至主存的 MAR,    (PC -> MAR)  
根据地址将存储器的内容读入 MDR, 然后送至控制器的 IR,  (MDR -> IR)  

分析:  
将 MDR 的指令的操作码送至 CU 分析,     (OP(IR) -> CU)  

执行:  
- 如果是取数, 则 CU 会将地址码送至 MAR 进行取数放入MDR,    (Ad(IR) -> MAR)  
    然后再放入运算器的ACC,  (MDR -> ACC)  
- ...

PC会自动加 1, 形成下一条指令的地址.  (PC) + 1 -> PC

    
## 计算机硬件的主要技术指标

- 机器字长:  
    机器字长是指 CPU 一次能处理的数据的位数, 通常与 CPU 的寄存器位数有关.  

- 存储容量:  
    存储器的容量应该包括**主存容量**和**辅存容量**.  
    存储容量 = 存储单元的个数 X 存储字长.  
    现代计算机常以字节数来描述容量的大小, 1字节 为 8位 二进制代码(1B = 8 bit).  
    1K = 2^10, 1M = 2^20, 1G = 2^30.  

- 运算速度:  
    计算机的运算速度与许多因素有关, 机器的主频, 程序的不同, 主存本身的速度等.  
    现在机器的运算速度普遍采用单位时间内执行指令的平均条数来衡量, 并用 MIPS(百万条指令每秒) 作为单位.  
    其他单位: CPI(执行一条指令所需的时钟周期, 机器主频的倒数), FLOPS(浮点运算次数每秒).  


# 系统总线

计算机的五大部件之间的互连方式有两种: 各部件之间单独连线(分散连接), 各部件连到一组公共信息传输线上(总线连接).  

总线是连接多个部件的信息传输线, 是各部件共享的传输介质.  
当多个部件与总线相连时, 如果出现多个部件同时向总线发生信息, 势必导致信号冲突, 传输无效.  
因此, 在某一时刻, 只允许有一个部件向总线发送信息, 而多个部件可以同时从总线上接收相同的信息.  


## 总线分类

按连接部件的不同, 介绍三类总线.  

- 片内总线:  
    片内总线是指芯片内部的总线, 如在CPU芯片内部, 寄存器与寄存器之间, 寄存器与算逻单元ALU之间都由片内总线连接.  

- 系统总线:  
    系统总线是指 CPU, 主存, I/O设备各大部件之间的信息传输线.  
    由于这些部件通常都安放在主板或各个插件板(插卡)上, 故又称板级总线或板间总线.  
    按系统总线传输信息的不同, 又可分三类: **数据总线**, **地址总线**, **控制总线**.  

- 通信总线:  
    这类总线用于计算机系统之间或计算机系统与其他系统(如控制仪表, 移动通信等)之间的通信.  
    按传输方式可分为两种: 串行通信, 并行通信.  


## 总线性能指标

- 总线宽度:  
    通常是指数据总线的根数, 用 bit(位) 表示.

- 总线带宽:  
    总线的传输速率, 单位: MBps(兆字节每秒).  
    总线带宽 = 总线工作频率(MHz) X 总线宽度(bit或B).  

- ...  


## 总线结构

### 单总线结构

将 CPU, 主存, I/O设备(通过I/O接口)都挂在一组总线上, 允许I/O设备之间, I/O设备与CPU之间, I/O设备与主存之间直接交换信息.  
这种结构简单, 也便于扩充, 但所有的传送都通过这组共享总线, 极易形成计算机系统的瓶颈. 不允许多个设备同时向总线传输信息, 必然会影响效率.  
这类总线多被小型计算机或微型机采用.  

### 多总线结构

双总线结构的特点是将速度较低的I/O设备从单总线上分离出来, 形成主存总线与I/O总线分开的结构.  
如果将速率不同的I/O设备进行分类, 然后将它们连接在不同的通道上, 效率将会更高, 由此发展成多总线结构.  


## 总线控制

由于总线上连接着多个部件, 各部件的传输等问题需要总线控制统一管理.  
它主要包括 **判优控制(或称仲裁逻辑)** 和 **通信控制**.  

### 总线判优控制

总线上连接的所有设备, 按其对总线有无控制功能可分为主设备(模块)和从设备(模块)两种.  

当多个主设备同时要使用总线, 就由总线控制器的判优, 仲裁逻辑按一定的优先等级顺序确定哪个主设备能使用总线.  

总线判优控制可分为**集中式**和**分布式**两种.  
集中式: 将控制逻辑集中在一处(如CPU).  
分布式: 将控制逻辑分散在与总线相连的各个部件或设备上.  

常见的**集中控制**优先仲裁方式有以下三种:  

- 链式查询:  
    - 控制总线中有3根线用于总线控制(BS总线忙, BR总线请求, BG总线同意).  
    - BG串行地从一个I/O接口到下一个I/O接口. 如果BG到达的接口有总线请求, BG信号就不再下传, 该接口获得总线总线使用权, 并建立总线忙BS信号, 表示它占用了总线.  
    - 特点: 只需几根线就能按一定优先次序实现总线控制, 并且很容易扩充设备, 但对电路故障很敏感, 且优先级别低的设备很难获得请求.  

- 计数器定时查询:  
    - 与链式查询相比, 多了一组设备地址线, 少了根总线同意线BG.  
    - 总线控制部件接到由 BR 送来的信号后, 在总线未被使用的情况下, 总线控制部件中的计数器开始计数, 并通过设备地址线向各设备发出一组地址信号.  
    当某个请求占用总线的设备地址与计数值一致时, 便获得总线使用权, 此时终止计数查询.  
    - 特点: 设备的优先顺序即设备地址的顺序; 计数也可以从上次终止位置开始, 即循环计数, 此时设备的优先级相等; 计数的初始值还可以由程序设置.

- 独立请求方式:  
    - 每一台设备均有一对总线请求线和总线同意线.  
    - 总线控制部件会按一定优先次序确定响应哪台设备的请求.  
    - 特点: 响应速度快, 优先次序灵活, 但控制线数量多, 总线控制更复杂.  

### 总线通信控制

通常将完成一次总线操作的时间称为总线周期, 可分为4个阶段:  

- 申请分配阶段:  
    由需要使用总线的主设备(模块)提出申请, 经总线仲裁机构决定下一传输周期的总线使用权授予某一申请者.  

- 寻址阶段:  
    取得使用权的主模块(设备)通过总线发出本次要访问的从模块(设备)的地址及相关命令, 启动参与本次传输的从模块(设备).  

- 传输阶段:  
    主模块和从模块进行数据交换.  

- 结束阶段:  
    从系统总线上撤除主模块的有关信息, 让出总线使用权.  

总线通信控制主要解决通信双方如何获知传输开始和结束, 以及通信双方如何协调配合.  
通常用四种方式: 同步通信, 异步通信, 半同步通信, 分离式通信.  


#### 同步通信

由统一时钟控制数据传送.  
时标通常由CPU的总线控制部件发出, 送到总线上的所有部件; 如果是各部件时序发生器发出, 需要由总线控制部件进行同步.  

包含4个时钟周期: T1, T2, T3, T4.  

| 时钟周期\读写命令 | 读命令 | 写命令 |
| ---  | ----- | ------ |
| T1   | 主模块发地址   | 主模块发地址 |
| T1.5 |               | 主模块提供数据 |
| T2   | 主模块发读命令 | 主模块发写命令, 从模块接到后将数据及时写入指定的地址单元 |
| T3   | 从模块提供数据 |  |
| T4   | 主模块撤销读命令, 从模块撤销数据 | 主模块撤销写命令和数据等信号 |

优点: 规定明确, 统一, 模块间的配合简单一致.  
缺点: 强制性"同步", 必须在限定的时间内完成规定的要求. 且对所有从模块都用同一限时(按最慢的部件设计时钟), 势必影响效率. 

同步通信一般用于总线长度较短, 各部件存取时间比较一致的场合.  


#### 异步通信

允许各模块的速度不一致.  
没有公共的时钟标准, 采用应答方式(又称握手方式).  

- 不互锁方式:  
    主模块发出请求信号后, 不必等待接到从模块的回答信号, 经过一段时间撤销其请求信号.  
    从模块接到请求信号后, ...  

- 半互锁方式:  
    主模块发出请求信号, 必须待接到从模块的回答信号后再撤销其请求信号.  
    从模块发出回答信号后不必等待请求信号撤销, 一段时间后自动撤销回答信号.  

- 全互锁方式:  
    ...  
    
异步通信可用于并行传送或串行传送.  

异步串行通信需要统一字符格式:  
1个起始位(低电平), 5~8个数据位, 1个奇偶校验位(检错用), 1或1.5或2个终止位(高电平).  
**传送时数据的二进制顺序是反向的**, 起始位后是字符的最低位.  
起始位至终止位结束构成一帧, 两帧之间的间隔可以是任意长度的.  
传送速率以**波特率**来衡量: 单位时间内传送的二进制位数(单位: bps).  


#### 半同步通信

在保留同步通信的基础上, 增加一条"等待($\overline{wait}$)"响应信号线, 采用插入时钟(等待)周期的措施来协调通信双方的配合问题.  
当模块工作较慢, 时间不够时就给出一个等待信号, 增加一个时钟周期(等待周期), 不够继续加.  

半同步通信适用于系统工作速度不高但又包含由许多工作速度差异较大的个类设备组成的简单系统.  
半同步的控制方式比异步简单, 在全系统内各模块又在统一的系统时钟控制下同步工作, 可靠性较高, 同步结构较方便.  
其缺点是对系统时钟频率不能要求太高, 故从整体上看, 系统工作的速度仍不是很高.  

#### 分离式通信

将一个传输周期(总线周期)分解为两个子周期.  
在第一个子周期中, 主模块在获得总线使用权后将命令、地址以及其他信息, 包括该主模块编号发到系统总线上, 给从模块接收. 发完之后立即释放使用权.  
在第二个子周期中, 从模块接收后准备回复的信息, 由从模块申请总线使用权, 进行同样的发送方式.  

这种方式控制比较复杂, 一般在普通微型计算机系统很少采用.  

# 存储器

## 概述

### 存储器分类

---

按存储介质分类:  

- 半导体存储器:  
    现代半导体存储器都用超大规模集成电路工艺制成芯片.  
    优点: 体积小, 功耗低, 存取时间短.  
    缺点: 当电源消失时, 所存信息也随即消失. 近年研制的非挥发性材料制成的存储器克服了信息易失的弊病.  
    
- 磁表面存储器:  
    在金属或塑料基体的表面上涂一层磁性材料作为记录介质. 用具有矩形磁滞回线特性的材料作磁表面物质, 按其剩磁状态的不同区分"0"或"1". 剩磁状态不易丢失, 这类存储器有非易失性的特点.  

- 磁芯存储器:  
    磁芯是由硬磁材料制作的环状元件. 在磁芯中穿有驱动线(通电流)和读出线, 进行读写操作.  
    逐渐被半导体存储器取代.  

- 光盘存储器:  
    应用激光在介质(磁光材料)上进行读写, 非易失.  
    由于光盘记录密度高, 耐用性好, 可靠性高, 可互换性强等特点, 其越来越被用于计算机系统.  

---

按存取方式分:  

- 随机存储器(RAM):  
    特点是存储器的任何一个存储单元的内容都可以随机存取, 而且存取时间于存储单元的物理位置无关.  
    计算机系统中的主存都采用都采用这种随机存储器.  
    由存储信息的原理不同, 又分为**静态RAM(触发器)**和**动态RAM(电容)**.  

- 只读存储器(ROM):  
    只读不写, 通常存放固定不变的程序、常数和汉字字库, 甚至用于操作系统的固化.  
    随着发展派生出: 可编程只读存储器, 可擦除可编程只读存储器, 电擦除可编程只读存储器, 闪速存储器.  

- 串行访问存储器:
    按存储单元的物理位置的先后顺序寻找地址, 如磁带.  
    还有一种属于部分串行访问的存储器, 如磁盘.   


### 存储器的层次结构

存储器有3个主要性能指标: 速度、容量、每位价格(位价).  
一般速度越高, 位价越高; 容量越大, 位价越低; 容量越大, 速度越低.  

层次:  寄存器 - 缓存 - 主存 - 磁盘 - 磁带  

寄存器通常在CPU内部, 有十几, 几十个.  
CPU, 缓存, 主存之间能直接交换信息.  
磁盘, 磁带都属于辅存. 辅存能与主存交换信息.  


## 主存储器

概述:  

[计算机组成](#计算机组成)

CPU读取数据时, CPU先将其地址送到MAR, 经地址总线送至主存, 然后发出读命令.  
主存接到读命令后, 读出数据, 由数据总线送至MDR.  
写数据与读类似.  

- 存储单元的地址分配:  
    通常计算机系统既可按字寻址, 也可按字节寻址. 一个字由几个字节组成.  
    字地址用该字高位字节或低位字节的地址表示.  


- 主存的技术指标:  
    - 存储容量:  
        存储容量 = 存储单元个数 x 存储字长 / 8 (字节)  
    - 存储速度:  
        **存取周期**, 指存储器进行连续两次独立的存储器操作所需的最小间隔时间.  (10 ns ~ 100 ns)


半导体存储芯片简介:  

存储芯片通过地址总线, 数据总线, 控制总线与外部连接.  
控制线主要有读写控制线与片选线两种. 存储器由多片芯片组成, 所以有片选确定是哪个芯片.  


### 随机存储器

- 静态RAM  
    用触发器(MOS管组成)存储信息, 断电时数据会丢失.  
- 动态RAM  
    用电容存储信息, 电容上的电荷一般只能维持 1 ~ 2 ms, 即使不断电也会自动消失, 所以需要刷新.  

- 动态RAM的刷新  
    先读出, 再重新写入.  
    一般刷新周期为2ms, 指每 2ms 必须刷新一次数据.  

    - 集中刷新  
        在一个刷新周期内集中一段时间逐行刷新, 此时必须停止读写操作. 这段时间称为 死时间 或 访存死区.  
    - 分散刷新  
        将每行的刷新分散到每个存取周期内. 存取周期前半段用来读写或维持信息, 后半段用来刷新.  
        这样不存在死时间, 但是需要更长的存取周期, 整个系统速度降低.  
    - 异步刷新  
        存取周期不变, 将每行的刷新平均分部在2ms内, 如有128行, 则 15.6μs 刷新一行.  
        如果将刷新安排在CPU对指令的译码阶段, 由于此时不会访问存储器, 可以方便刷新.  

- 动态RAM与静态RAM的比较  
    动态比静态的应用要广泛的多:  
    - 动态结构简单, 集成度远高于静态RAM.  
    - 动态RAM行列地址按先后顺序输送, 减少了芯片引脚, 封装尺寸也减少.  
    - 动态RAM的功耗比静态小.  
    - 动态RAM的价格更便宜.  
  
    动态RAM的缺点:  
    - 由于使用动态元件(电容), 因此速度比静态RAM低.  
    - 动态RAM需要配置再生电路, 也需要消耗一部分功率.  


### 只读存储器

- 掩模ROM  
    行列交叉处固定MOS管, 有即'1', 无即'0'.  
    在生产时就已固定状态, 无法改变.  

- PROM  
    一次性编程只读存储器.  
    单元由双极型电路和熔丝构成, 熔断为'0', 未熔断为'1', 熔丝断后无法恢复, 只能一次编程, 不能修改.  

- EPROM  
    可擦除可编程只读存储器.  
    ...  


### 存储器与CPU的连接

- 存储容量的扩展  
    - 位扩展: 略
    - 字扩展: 略
    - 字, 位扩展: 略

- 存储器与CPU的连接  
    - 地址线  
        CPU的地址线数往往比存储芯片的地址线数多.  
        将CPU的低位与存储芯片地址线相连, 高位地址线用于扩充或片选等.  
    - 数据线  
        CPU的数据线数与存储芯片的数据线数也不一定相等.  
    - 读写命令线  
        通常高电平为读, 低电平为写. 有些CPU的读写命令线是分开的
    - 片选线  
        存储器由许多存储芯片组成, 哪一片被选中取决于该存储芯片的片选控制端 $\overline{CS}$ 是否有CPU的片选有效信号.  
    - 合理选择存储芯片  
        通常选用 ROM 存放系统程序, 标准子程序和各类常数等.  
        RAM则是为用户编程而设置的.  


### 存储器的校验

在计算机运行过程中, 由于种种原因致使数据在存储过程中可能出现差错.  
为了能及时发现错误并纠正, 通常会将原数据配成汉明码.  

[内存纠错科普](https://www.bilibili.com/video/BV1GF411V7sC)

- 汉明码的组成:  
    在代码的第 2^(k-1) (k = 1, 2, ...) 位上增加纠错码, 承担"奇偶检错"任务.  
    在第 2^(k-1) 位上的纠错码负责检测 (2^(k-1) ~ 2^k-1) x (2n-1) (n = 1, 2, ...) 这些位置上的数据.  

- 汉明码的纠错:  
    使用偶检验时, 将各位纠错码与其负责的数据位进行异或运算, 将结果组成一个二进制数, **靠后的为数的高位**.  
    其代表的就是出错的数据的位置, 如果为0, 就表示没错.  
    如果是奇校验, 异或后取非(即同或运算), 其他步骤一致.  


### 提高访存速度

1. 单体多字系统:  
    程序与数据在存储体内是连续存放的, 因此 CPU 访存取出的信息也是连续的, 如果可以单存取周期内一次取出多条指令, 逐条发给 CPU 执行, 可以显著提高存取速度.  

2. 多体并行系统:  
    多体即多个模块, 每个模块有独立的 MAR, MDR 等, 可以并行或交叉工作.  
    - 高位交叉编址的多体存储器:  
        体内地址连续存放(一个体存放满后, 再存入下一个体). 多个体可并行存储.  
        这种编制方式有利于扩充.  
    - 低位交叉编址的多体存储器:  
        程序连续存放在相邻体中. 体内的地址为等差数列, 差值即存储体的个数.  
    高位的在取连续地址时只有一个体在工作, 而低位的因为地址的下一位在相邻的下一个存储体中, 所以取连续的地址也需要多个体并行工作(效率高).  

    设存储器模块数为 n, 存取周期为 T, 总线传输周期为 t, 采用流水线方式存取时, 应满足 T = nt.  
    连续读取n个字: 低位所需时间: T+(n-1)t; 高位: nT.  

3. 高性能存储芯片:  
    俗话说: 大力出奇迹. 只要我芯片性能够好, 就不需要那些花里胡哨的()  
    DRAM(动态随机存储器), 广泛应用于主存. 其发展速度很快. 有SDRAM, RDRAM, CDRAM.  


## 高速缓冲存储器(Cache)

在CPU与主存之间加一级缓存, 缓解CPU与主存速度不匹配的问题, 避免CPU与I/O设备争抢访存. 

程序访问的局部性原理:  
在一定时间内, CPU 往往只对主存的局部地址区域进行访问.  
由于指令和数据的在内存都是连续存放的, 并且有些指令和数据往往会被多次调用, 即指令和数据在主存的地址是相对簇聚的, 访存具有相对的局部性.  

工作原理:  
将 Cache 与主存分块, 它们的块大小相同.  
将一些主存块放入缓存块中. CPU 读主存的某字时, 如果已在缓存中, 可直接访问 Cache; 如果不在, 需同时将对应得主存块调入 Cache. 写入时需要保证两份数据的一致性.  
可将地址分为两段: 块号 与 快内地址.  

Cache 的改进:  
分级, 建立多级缓存.  
分立, 将指令和数据放入不同的缓存中.  


### Cache-主存地址映射

由主存地址映射到 Cache 地址称为地址映射.  
映射方式: 直接映射(固定的映射关系), 权相联映射(灵活性大的映射关系), 组相联映射(前两种映射的折中).  

1. 直接映射:  
    每个主存块只与一个缓存块对应, 映射关系为:  
    i = j mod C 或 i = j mod 2^c  
    i 为缓存块号, j 为主存块号, C 为缓存块数, c 缓存字块地址位数.  

    将地址分三段: | 主存字块标记(t位) | Cache字块标记(c位) | 块内地址(b位) |  

    这种方式实现简单, 只需要利用主存地址的某些位直接判断, 即可确定所需字块是否在缓存中.  
    每个主存块只能固定地对应某个缓存块, 缓存的存储空间得不到充分利用.  

2. 全相联映射:  
    全相联映射允许主存中每一字块映射到 Cache 的任何一块位置上.  
    这种方式成本较高, 地址的比较次数较多.  

3. 组相联映射:  
    将 Cache 分为 Q 组, 每组 R 块, i = j mod Q.  
    缓存的一个组中映射R个随机的主存块.  


### 替换策略

当新的主存块需要调入 Cache 并且它的可用空间位置又被占满, 需要替换掉 Cache 的数据, 因此产生替换策略(算法)问题.  

在直接映射的 Cache 中, 主存块与唯一缓存块有映射关系, 所以替换策略很简单.  
而在组相联和全相联映射的 Cache 中, 主存块可以写入 Cache 中多个位置, 需要替换策略.  

1. 先进先出(First-In-First-Out, FIFO)算法:  
     FIFO 算法选择最早调入 Cache 的字块进行替换.  
2. 近期最少使用(Least Recently Used, LRU)算法:  
     LRU 算法比较好地利用访存局部性原理, 替换最近用得最少的字块. 需要记录 Cache 中各字块的使用情况.  
     这种方法比较复杂, 一般采用简化的方法, 只记录每个块最近一次使用的时间.  
3. 随机法:  
     随机地确定被替换的块, 比较简单, 但和 FIFO 一样无法提高 Cache 的命中率.  


## 辅助存储器*

又称外部存储器, 简称外存.  
与主存相比, 辅存具有容量大, 速度慢, 价格低, 可脱机保存信息等特点, 属于"非易失性"存储器.  
目前, 广泛使用的有 硬磁盘, 软磁盘, 磁带, 光盘等.  


磁表面存储器的主要技术指标:  
1. 记录密度:  
    为了避免干扰, 磁道之间保持一定距离, 相邻磁道的距离称为道距(P). 道密度: $D_t = \frac{1}{P}$ , 单位 tpi(道每英寸)或 tpm(道每毫米).  
    位密度或线密度(单位: bpi或bpm): 对于磁盘, $D_b = \frac{f}{πd_{min}}$. f 为每道总位数, d_min 为最小磁带直径.  

2. 存储容量  
3. 平均寻址时间
4. 数据传输效率
5. 误码率


[机械盘与固态盘](https://www.bilibili.com/video/BV1dE411k7tU)

光盘的介质互换性好, 存储容量大, 可用于文献档案, 图书管理, 多媒体等方面的应用. 但由于目前价格比较贵, 故尚不能替代磁带机.  
硬磁盘存储器容量大, 数据传输率比光盘高, 等待时间短. 作为主存的后备存储器.  
软磁盘存储器容量小, 数据传输率低, 平均寻道时间长, ... 近年来已逐渐被淘汰.  
磁带, 逐渐被磁盘取代.  



# 输入输出系统

## 概述

### 发展过程

1. 早期阶段:  
    I/O 设备比较少, I/O 设备与主存交换信息都必须经过 CPU.  
    - 每个 I/O 设备都必须配有一套独立的逻辑电路与 CPU 相连, 线路散乱庞杂.  
    - 输入输出过程穿插在 CPU 执行程序过程中, 需要 CPU 停止工作.  
    - 每个 I/O 设备的逻辑控制电路与 CPU 的控制器紧密相连, 变更十分困难.  

2. 接口模块和 MDA 阶段:  
    I/O 设备通过接口模块与主机连接, 计算机系统采用总线结构.  
    出现直接存储器存取(DMA)技术, I/O 设备与主存之间有一条直接数据通路.

3. 具有通道结构的阶段:  
    用通道来负责管理 I/O 设备之间交换信息的部件, 可以视为一种具有特殊功能的处理器.  

4. 具有 I/O 处理机的阶段:  
    I/O 处理机又称为外围处理机, 它独立于主机工作, 既可完成 I/O 通道的 I/O 控制, 又可完成码制变换, 格式处理, 数据块检错, 纠错等操作.  

主要介绍第二阶段的输入输出系统. 其后阶段的介绍在 "计算机体系结构" 课程.  


### 输入输出系统的组成

输入输出系统由 **I/O 软件**和 **I/O 硬件**组成.  

- I/O 软件  
    - I/O 指令: 是机器指令的一类.  
        一般格式:  | 操作码 | 命令码 | 设备码 |  
        操作码将其与其他指令区别开. 命令码为具体的操作. 设备码是对设备的选择.  
    - 通道指令: 通道自身的指令.  
        指出数据的首地址, 传送字数, 操作命令.  
        通道指令放在主存中.  
        由 CPU 执行启动 I/O 设备的指令, 由通道代替 CPU 对 I/O 设备进行管理.  

- I/O 硬件  
    一般包括接口模块及 I/O 设备.  
    主机 <-> I/O接口 <-> 设备控制器 <-> 设备


### I/O设备与主机信息传送的控制方式

1. 程序查询方式
    由 CPU 通过程序不断查询 I/O 设备是否已做好准备, 从而控制 I/O 设备与主机交换信息. 期间CPU会终止原程序的执行. 这种方式CPU的工作效率不高.  

2. 程序中断方式
    CPU 在启动 I/O 设备后, 继续执行自身程序. 当 I/O 设备准备就绪时, 向 CPU 发出中断请求, 得到响应.  

3. DMA 方式  
    主存与I/O设备之间有一条数据通路, 主存与I/O设备交换信息时, 无须调用中断服务程序, 即不会占用CPU. CPU 与 DMA 同时访问主存, CPU会让给DMA(称窃取或挪用).


## I/O设备

中央处理器和主存构成了主机, 除主机外的大部分硬件设备都可称为 I/O 设备或外部设备, 或外围设备, 简称外设.  

I/O 设备的大致分类:  
1. 人机交互设备  
    如键盘, 鼠标, 手写板, 摄像机..., 打印机, 显示器...  
2. 计算机信息存储设备  
    即辅助存储器, 如磁盘, 固态盘...  
3. 机-机通信设备  
    如调制解调器, 数/模或模/数转换器..., 计算机网络.  


### 输入输出设备

- 键盘:  
    1. 按下一个键.  
    2. 查出按下的是哪个键.  
    3. 译成 ASCII 码, 由主机接收.  

- 鼠标:  
    常用的有机械式和光电式.  
    通过底部的传感器检测运动的方向和距离, 从而控制光标移动.  

- 显示器:  
    按显示器件分: 阴极射线管(CRT)显示器, 液晶显示器(LCD), 等离子显示器(PD)等.  
    按所显示的信息内容分为: 字符显示器, 图形显示器, 图像显示器.  
    
    指标:  
    - 屏幕大小: 按屏幕对角线长度表示.  
    - 分辨率: 像素个数, 以宽高的像素乘积表示.  
    - 灰度级: 像素点的亮暗或颜色差别, 8位(256级), 16位等.  
    - 刷新频率: 光点一般维持几十毫秒, 需要不断刷新, 一般在 60 ~ 120Hz.  
    - 显示存储器(VRAM): 为了不断刷新, 需要保存瞬时的图像信息, 又称刷新存储器, 帧存储器, 视频存储器. 其大小为: 分辨率 x 灰度级位数 (bit).  

### I/O接口

I/O接口指 主机 与 I/O设备 之间设置的一个硬件电路及其相应的软件控制.  

I/O总线:  
    - 数据线
    - 设备选择线
    - 命令线
    - 状态线

接口功能:  
    - 实现设备选址  
    - 实现数据传送  
    - 传送控制命令
    - 实现数据转换(串并，电平)
    - 反应设备状态

接口类型:  
    - 按数据传送方式: 并行接口, 串行接口.  
    - 按功能选择的灵活性: 可编程接口, 不可编程接口.  
    - 按通用性: 通用接口, 专用接口.  
    - 按数据传送的控制方式: 程序型接口, DMA型接口.  


## 程序查询方式

三条指令:  
- 测试指令: 查询 I/O 设备是否准备就绪.  
- 传送指令: 就绪后执行传送指令.  
- 转移指令: 未就绪, 执行转移指令, 转至测试指令.  

查询流程:  
1. 保护CPU寄存器内容.  
2. 设置计数值, 设置主存缓冲区首址.  
3. 启动 I/O 设备.  
4. 循环查询I/O设备是否准备好.  
5. 准备好后, 传送一次数据(一个字), 修改主存地址, 修改计数值.  
6. 检测是否传送完(计数为 0), 否则重新启动外设继续传送.  
7. 传送完成则继续执行之前的程序.  

接口电路:  
- 设备选择电路: 当地址线与设备码一致时输出 SEL 有效.  
- 设备状态寄存器: 由两个触发器构成并控制状态.  
- 数据缓冲寄存器: 用于存放欲传送的数据.  


## 程序中断方式

- 中断:  
    在执行中程序, 出现了异常情况或特殊请求, 停止程序的执行, 对其进行处理, 结束后再继续执行原程序.  

- I/O 中断:  
    CPU 启动设备后继续执行现行程序, 当 I/O 设备准备完成后向CPU发出中断请求.  


接口电路:  
- 中断请求触发器, 中断屏蔽触发器:  
    每台外部设备都配有一个中断请求触发器 INTR, 其值为 1 时, 表示发出中断请求.  
    I/O 接口中设置一个屏蔽触发器 MASK, 其值为 1 时, 会屏蔽I/O设备发出中断信号. 其目的是防止多个低级别的中断源中断正在运行的中断服务程序.  

- 排队器:  
    当多个中断源同时发出中断请求时需要由一个排队器按优先级别排队.  
    链式排队器: 高优先级发出中断请求后, 会阻止其后的设备发出中断请求.  

- 设备编码器:  
    不同设备的中断服务程序不同, 编码器会给出发出中断请求的中断服务程序的入口地址. 由 INTR1 ~ INTRn 编码成对应的二进制地址.  

单重中断流程:  
- 中断周期:  
    1. 中断响应
    2. 程序断点进栈
    3. 关中断
    4. 向量地址 -> PC
- 中断服务程序:  
    1. 保护现场.  
    2. 中断服务.  
    3. 恢复现场. 
    4. 开中断, 中断返回.  

中断服务程序可被中断时, 称为多重中断(中断嵌套); 中断服务不可被中断时, 称为单重中断.  
多重中断将 "开中断" 的时间提前至 "保护现场" 与 "中断服务" 之间.  


## DMA方式

主存与DMA 接口之间有一条数据通路, 因此主存与设备交换信息不需要通过 CPU.  
适合高速 I/O 或 辅存 与主存之间的信息交换. 因为高速I/O设备若每次都要等待 CPU 做出中断响应再进行信息交换, 很可能会造成数据丢失.  


DMA 接口与 CPU 共享主存, 两者之间可能产生冲突.  
有三种解决方案:  
- 停止 CPU 访问主存:  
    DMA 接口向 CPU 发出一个停止信号, 要求 CPU 放弃总线控制权, 用完后归还.  
    控制简单, 但此时 CPU 基本上处于不工作状态, CPU 对主存的利用不充分.  

- 周期挪用(窃取):  
    I/O设备挪用总线占用权一个或几个主存周期.  
    - CPU 未访问主存, 此时不发生冲突.  
    - CPU 正在访问主存, 需等待存取周期结束, CPU 让出总线占有权.  
    - 同时访问主存, I/O优先于 CPU, 防止数据丢失.  
    适用于 I/O设备的读/写周期 大于 主存周期 时.  

- DMA 与 CPU 交替访问:  
    将一个 CPU 周期分为两个分周期, 前分周期供 DMA 访存, 后分周期供 CPU 访存.  
    此方式硬件逻辑较为复杂.  
    适合于 CPU的工作周期 大于 主存存取周期 时.  

### DMA接口的功能和组成

功能:  
- 向 CPU 申请 DMA 传送.  
- 处理总线控制权的转交.  
- 在 DMA 期间管理系统总线, 控制数据传送.  
- 确定数据传送的起始地址和数据长度, 并在传送过程中进行修正.  
- 在传送结束时, 给出 DMA 操作完成信号.  

组成:  
- 主存地址寄存器(AR): 存储需要交换数据的地址.  
- 字计数器(WC): 每传送一个字, 计数器加 1, 直到为 0(最高位进位), 表示传送完成.  
- 数据缓冲寄存器(BR): 暂存数据. 可能还有数据位移缓冲寄存器, 字节计数器等.  
- DMA 控制逻辑: 负责管理 DMA 传送过程, 由控制电路, 时序电路及命令状态控制寄存器等组成.  
- 中断机构: 字计数器溢出时, 向 CPU 提出中断请求.  
- 设备地址寄存器(DAR): 存放 I/O 设备的设备码或寻址信息.  

工作过程:  
1. 预处理: CPU 需要预置一些信息.  
    - 指明数据传输方向, 写入或读出.  
    - 传送设备号, 并启动设备.  
    - 传送需交换数据的主存起始地址.  
    - 传送需交换的字个数.  

2. 数据传送: ...  

3. 后处理:  
    - 校验送入主存的数据是否正确.  
    - 是否继续传送其他数据块.  
    - 传送过程中是否发生错误. 如果有,则转错误诊断及处理错误程序.  



# 运算器

## 数

### 定点数

- 无符号数与有符号数  
    符号即正负号, 无符号即只有正数, 有符号有正负之分. 有符号数需要最高位来表示正负号(0为正, 1为负), 所以同数位的无符号数表示的范围是有符号的近两倍.  
    +0 与 -0 的表示不一样.  

- 原码  
    符号位加上二进制数绝对值, 即原码.  
    小数一般指[0, 1]之间的纯小数, 如 -0.101 的原码为 1.101  

- 补码  
    正数的补码为其本身, 负数的补码为 2^n + x(n为数的位数, 对于小数: n = 1).  

- 反码  
    反码通常作为求补码或原码的中间过渡.  
    正数的反码为其原码本身.  
    负数的反码为其原码各位取反.  

补码 = 反码 + 1.  
加 1 的位置是末尾, 对于整数即 +1, 对于小数是 +2^-n.  

- 移码  
    用补码表示数字时, 其大小不能直接判断. 所以将其最高位(符号位)加 1, 即加上 2^n.  
    这样将其按大小直接从 0 到 2^n - 1 排列, 00000 ~ 11111.  


### 浮点数

- 定点数:  
    小数点的位置固定.  

- 浮点数:  
    小数点位置不固定. 采用科学计数法表示.  

浮点数的表示:  
$ N = S * r^j $  
- S: 尾数, 可正可负.  
- j: 阶码, 可正可负.  
- r: 基数(基值), 可取2, 4, 8, 16等, 一般为 2.  

为了提高数据精度以及便于浮点数的比较, 尾数用纯小数表示.  
尾数最高位为 1 的浮点数称为规格化数, 即 0.1 ... . 此时其精度最高.  

浮点数的表示:  
| 阶符 | 阶码数值(m位) | 数符 | 尾数数值(n位) |  

浮点数表示范围(基数为 2):  
2^(-2^m + 1) * 2^-n < | N | < 2^(2^m - 1) * (1 - 2^-n)  


### IEEE 754 标准

| 数符 | 阶码(含阶符) | 尾数 |  

常用浮点数:  
| 浮点数                | 符号位S | 阶码 | 尾数 | 总位数 |
| -------------------- | ------- | --- | ---- | ------ |
| 短实数(float)         |   1    |  8   |  23  |   32   |
| 长实数(double)        |   1    |  11  |  52  |   64   |
| 临时实数(long double) |   1    |  15  |  64  |   80   |

阶码用移码表示, 为 真值 加上 一个常数(偏移量), 短实数, 长实数, 临时实数的偏移量分别为 7FH, 3FFH, 3FFFH.  
位数部分通常都是规格化(1.M), 用原码表示.  


## 定点运算

### 位移运算

对于有符号数的位移称为**算术移位**, 无符号数的位移称为**逻辑位移**.  
**算术位移时, 符号位不变, 仅数值位位移.**  

- 原码:  
    右移: 高位补 0, 低位舍弃. 若舍弃的为 0, 相当于 * 1/2; 为 1, 则**丢失精度**.  
    左移: 低位补 0, 高位舍弃. 若舍弃的为 0, 相当于 * 2; 为 1, 则出现**严重误差**.  
- 反码: 正数时与原码相同, 负数时与原码相反, 补位为 1.  
- 补码: 正数时与原码相同; 负数时, 左移补 0(同原码), 右移补 1(同反码).  

循环位移时, 舍弃的位补至丢失位.  


### 加减法运算

计算机机中一般采用补码作加减法运算.  

原码: 符号位不参与运算.  
符号相同时, 绝对值相加, 符号不变.  
符号不同时, 绝对值大的减小的, 符号取较大值的.  

补码: 符号位参与运算.  
两个数的**和的补码**等于其**补码的和**; 减法将被减数取其相反数再求补码, 转换为加法.  

同符号数相加可能会产生溢出.  
溢出判断:  
- 如果计算结果与原符号不同, 则视为溢出.  
- 最高位的进位与符号位的进位不同时, 为溢出.  
- 采用双符号位, 正数: 00, 负数: 11. 计算后符号位不同则为溢出.  

加减法一般都是用补码进行运算, 可以将减法转换成加法.  


### 乘法运算

模仿列竖式计算的方式, 利用加法和位移, 进行乘法运算.  

符号位单独处理, 进行异或运算.  
数值位:  
1. 从乘数的低位开始, 如果为 1, 则部分积(初始为0)高位加上被乘数, 如果为 0, 则加 0.  
2. 将结果和乘数右移一位. 部分积低位保留, 不舍去, 但不会参与后面的加法; 乘数低位不保留.  
3. 重复1, 2 步骤直到被乘数全部移除.  

在运算器中, ACC(累加器)存放乘积高位, MQ(乘商寄存器)存放乘积低位和乘数, X存放被乘数. ACC 的低位 与 MQ 的高位相连.  
计算过程中, 乘积和乘数都不断右移(乘数的低位不断丢失), 可以放在同一寄存器中.  
最后移完再加上符号位就计算完成.  


**补码的乘法运算**(符号位参与运算):  
当乘数为正数时可按照原码进行运算, 当乘数为负数时, 去掉符号位进行运算, 最后加上乘数的相反数的补码进行校正.  
- Booth算法, 无论乘数为正或负, 都可以用其进行补码的乘法运算.  
    乘数末位: y_i, 附加位(初值为0): y_i+1, 如何运算取决 (y_i+1 - y_i)的值.  
    | y_i y_i+1 | 操作 |
    | --------- | ---- |
    | 01 | 部分积 + 乘数补码, 右移一位 |
    | 10 | 部分积 + 乘数相反数的补码, 右移一位 |
    | 00/11 | 部分积右移一位 |

    因为乘数也不断右移, 所以 y_i y_i+1 一直为乘商寄存器最低两位.  
    最后一步运算后不进行移位, 其符号也是由运算得出.  


- 两位乘:  
    乘数一位一位地取出, 根据0/1判断加的数值.  
    为了提升乘法运算速度, 可采用两位乘. 即每次取乘数的两位.  

    | 乘数 y_n-1 y_n | 部分积 |
    | -- | ------------- |
    | 00 | 部分积右移两位 |
    | 01 | 加上被乘数后右移两位 |
    | 10 | 加上两倍被乘数后右移两位 |
    | 11 | 加上三倍被乘数后右移两位 |

    补码的两位乘法共有 8 种情况.  


### 除法运算

除法也模仿竖式计算的方式进行运算.  

**原码**:  
符号位单独处理, 进行异或运算.  
ACC 存放被除数与余数, MQ 存放商, X 存放除数.  
- 恢复余数法:  
    先默认被除数大于除数, 即商先默认为 1.  
    被除数 - 除数, 即 + 除数补码.  
    如果余数为负数, 被除数加除数, 将商改为 0.  
    再ACC, MQ 左移. 由此循环.  

- 加减交替法:  
    又称 不恢复余数法, 是对恢复余数法的一种改进.  
    余数为负数时, 商 0. 无需恢复余数, 直接左移再加除数, 可得到下一步的余数.  
    余数为正数时, 商 1. 左移再减除数, 得到下一步的余数.  
    余数的正负性与商相同.  
    最后一次得到余数, 不进行位移, 如果余数为负, 需要加上除数的绝对值的补码.  

定点小数除法的商也只能用定点小数表示.  
所以要求此时 | 被除数 | ＜ | 除数 |.  


**补码**:  
加减交替法:  
- 被除数和除数同号, 被除数 减 除数, 异号则加.  
- 余数和除数同号, 商 1, 余数左移减除数; 异号, 商 0, 余数左移加除数.  
- 重复.  

- 对于商的精度没有特殊要求时, 末位恒置 1.  


## 浮点运算

### 浮点加减法

步骤:  
1. 对阶: 使浮点数阶码一致, 较小者增加.  
2. 尾数加减.  
3. 规格化.  
4. 舍入: 右移时丢失数据位.  
5. 溢出判断: 阶码溢出.  

- 规格化:  
    当基值为 2 时, 尾数 |S| 的范围应为 [ 1/2, 1).  
    如果采用双符号位的补码:  
    S > 0 时, [S]补 = 00.1XXX; S < 0 时, [S]补 = 11.0XXX;  
    此时, -1/2(补码) 不是规格化数, -1(补码) 是规格化数.  

- 舍入:  
    在对阶和右规的过程中, 可能会将尾数的低位丢失, 影响精度.  
    为此用舍入法提高尾数精度. 常用的有两种舍入法:  
    - 0舍1入法:  
        对于移去的最高位: 为0则舍去, 为1则末尾加1. 可能会再次导致溢出, 需要再次右规.  
    - 恒置1法:  
        无论舍去的最高位为0或1, 尾数末尾恒置为1.  

- 溢出判断:  
    尾数的溢出可以进行规格化(右规), 所以并不算溢出.  
    溢出的判断为: 右规后, 阶码溢出.  


### 浮点乘除法

阶码加减, 尾数乘除.  
...  


## 算术逻辑单元

ALU(Arithmetic and Logic Unit).  
电路组成:  
两个输入端, 一个输出端, 一个控制端(控制运算种类).  

### 快速进位链

进位计算:  
$ C_i = A_i B_i + (A_i+B_i)C_{i-1} $  
本地进位 $ A_i B_i $ 记为 $ d_i $, 与低位无关.  
传递条件 $ A_i+B_i $ 记为 $ t_i $, 传递进位 $ t_i C_{i-1} $ 与低位有关.  
$ C_i = d_i + t_i C_{i-1} $  


串行进位链:  
进位信号采用串行传递, 每一位的结果和进位输出需要等待前一位的进位信号.  
高位将会有非常大的延迟时间.  

并行进位链:  
进位信号同时产生, 无需等待低位的进位信号. 即将每位的输入及其全部低位输入一起参与运算, 每位的进位信号可同时算出.  
但高位的电路逻辑非常庞大.  

- 单重分组跳跃进位:  
将 n位全加器分为若干小组, 小组内的进位同时产生, 小组间采用串行进位. 即组内并行, 组间串行.  
当小组数过多时, 同样会加大延时.  

- 双重分组跳跃进位:  
将若干小组可以看作一个大组, 每个小组的最高位进位可同时得出(只与组内输入和外来进位C-1有关).  


# 指令系统

- 机器指令:  
每一条机器语言的语句称为机器指令, 机器指令的集合称为**指令系统(指令集)**.  

## 指令的一般格式

**指令**由**操作码**和**地址码**构成.  
| 操作码字段 | 地址码字段 |   

- 操作码:  
    操作码用来指明该指令所要完成的操作.  
    操作码的长度可以是固定的, 也可以是变化的.  
    - 前者格式便于硬件设计, 指令译码时间短, 广泛用于字长较长的、大中型计算机和超级小型计算机以及RISC中.  
    - 非固定格式可以有效地压缩操作码的平均长度, 在字长较短的微型计算机中被广泛采用. 长度不固定会增加译码和分析的难度, 通常采用扩展操作码技术.  
    - 扩展操作码: 将地址字段分成若干段, 其可被操作码占用. 根据地址的段数可分为 零地址指令, 一地址指令, 二地址指令... 较长的指令(地址段数少)的操作码开头不可与短指令重复(类似哈夫曼树).  


- 地址码:  
    地址可以是主存或寄存器或 I/O设备的地址.  
    1. 四地址指令: (A1)OP(A2) -> A3  
        A1: 第一操作数地址, A2: 第二操作数地址, A3: 结果地址, A4: 下一条指令地址. 需要四次访存(取指, 取操作数两次, 存放结果).  
    2. 三地址指令: (A1)OP(A2) -> A3  
        后续指令的地址隐含在程序计数器PC中, 可自动计算下一条指令的地址. 需要四次访存.  
    3. 二地址指令: (A1)OP(A2) -> A1  
        A1既是源操作数的地址, 又是结果存放的地址. 或者存放在A2. 需要四次访存.  
    4. 一地址指令: (ACC)OP(A1) -> ACC  
        ACC既存放操作数, 又存放计算结果. 需要两次访存.  
        或者: OP(A1) -> A1, 需要三次访存.  
    5. 零地址指令:  
        一些指令无地址码, 如 空操作(NOP), 停机(HLT)...  
        或者堆栈计算机, 两个操作数隐含存放在栈顶和次栈顶, 计算结果压回栈顶.  

    地址个数越少, 在操作码长度固定时其位数越大, 可表示的寻址范围越大.  

- 指令字长:  
    早期的指令字长与机器字长, 存储字长相等, 指令字长固定.  
    随着发展, 指令系统可以采用位数不同的指令. 但控制电路比较复杂.  
    通常将常用的指令设计成单字长或短字长格式的指令.  
    指令字长通常取 8 的整数倍.  


## 操作数类型和操作类型

### 操作数类型

- 地址:  
    地址也可以视为一种数据, 无符号整数.  
- 数字:  
    计算机中常见的数字有定点数, 浮点数和十进制数.  
- 字符:  
    字符是一种常见的数据类型, 通常以 ASCII 码等形式存储和传输.  
- 逻辑数据:  
    有bool类型数据和其他逻辑数.  


由于数据字长不一致, 为了便于硬件实现, 要求多字节数据存储要满足"边界对准".  
半字地址为2的整数倍, 一字地址为4的整数倍...


### 操作类型

1. 数据传送:  
    各寄存器, 各存储单元之间的传送.  
2. 算术逻辑操作:  
    实现算术运算与逻辑运算.  
3. 移位:  
    可分为算术移位, 逻辑移位, 循环移位.  
4. 转移:  
    可以用转移指令改变指令的执行顺序. 按转移特征可分为无条件转移, 条件转移, 跳转, 过程调用与返回, 陷阱等.  
    - 无条件转移:  
        不受任何条件约束, 直接将程序转移到指定的指令地址. 如: JMP X, 将指令地址无条件转至X.  
    - 条件转移:  
        根据当前指令的执行结果来决定是否转移. 一般机器都能提供一些条件码(表示某些操作的结果). 如: BRO X, 若结果(有符号数)溢出(V=1), 则跳转至X.  
    - 调用与返回:  
        通常调用指令包括: 过程调用, 系统调用, 子程序调用.  
        调用指令(CALL)一般与返回指令(RETURN)配合使用.  
    - 陷阱与陷阱指令:  
        陷阱是一种意外事故的中断.  
        陷阱指令一般不提供给用户直接使用, 而作为隐指令, 在出现意外故障时, 由CPU自动产生并执行.  
5. 输入输出:  
    对于I/O单独编址的计算机而言, 通常设有输入输出指令. 完成从外设寄存器到CPU寄存器之间的数据传送.  
6. 其他:  
    其他包括等待指令, 停机指令, 空操作指令, 开中断指令, 关中断指令, 置条件码指令等.  


## 寻址方式

寻址方式指确定本条指令的数据地址以及下一条指令的地址的方式.  
与硬件结构紧密相关.

- 指令寻址:  
    分为顺序寻址与跳跃寻址.  
    顺序寻址由程序计数器 PC+1 自动形成.  
    跳跃寻址由转移指令完成.  

- 数据寻址:  
    由于数据寻址方式较多, 在指令字中必须设一字段来表明其寻址方式.  
    指令的地址码通常都不代表操作数的真实地址, 称为**形式地址**, 记作 A.  
    真实地址称为**有效地址**, 记作 EA.  
    指令格式: **| 操作码 | 寻址特征(方式) | 形式地址A |**  
    注: 为方便分析研究, 假设指令字长, 存储字长, 机器字长均相同.  

    - 立即寻址:  
        操作数本身设在指令字内, 即形式地址 A 不是操作数的地址, 而是操作数本身, 又称为立即数(补码).  
    - 直接寻址:  
        形式地址 A  就是 真实地址 EA.  
    - 隐含地址:  
        操作数的地址隐含在操作码或某个寄存器中. 如 隐含在累加器ACC中.  
    - 间接寻址:  
        形式地址指出真实地址的存储单元. 可套娃.  
        形式地址 < 指令字长 = 存储字长.  
    - 寄存器寻址:  
        地址码字段指出寄存器的编号. 操作数存于寄存器内.  
    - 寄存器间接寻址:  
        寄存器中存储的不是操作数, 而是操作数的真实地址.  
    - 基址寻址:  
        需要设有基址寄存器 BR(或用通用寄存器), 其操作数的有效地址 EA 等于指令字中的形式地址与基址寄存器的内容相加, EA = A + (BR).  
        基址寄存器的内容通常由操作系统或管理程序确定, 在程序执行过程中值不变. 通常存放程序的起始地址(记录于PCB中).  
    - 变址寻址:  
        与基址寻址极为相似, 有效地址 EA 等于形式地址 A 与变址寄存器 IX 的内容相加, EA = A + (IX).  
        变址寄存器的内容由用户设定, 程序执行过程中其值可变.  
        可设定 A 为数组首地址, (IX) 为下标, 适合编制循环程序.  
    - 相对寻址:  
        将PC的内容与指令的地址相加, EA = (PC) + A.  
        通常用于转移类指令. A 又称为位移量, 可正可负, 通常为补码.  
    - 堆栈寻址:  
        计算机中设有堆栈, 可用寄存器组实现(称为硬堆栈), 也可以用部分主存作为堆栈(软堆栈).  
        操作数只能从栈顶地址指示的存储单元存取. 有一个栈顶指针(SP)指出栈顶地址.  


## RISC(精简指令系统)

RISC, 即精简指令系统计算机; 对应的为 CISC, 即复杂指令系统计算机.  
有很多指令是不常用的, 80%的语句仅使用了20%的指令, 所以可以进行精简.  

### 特征

- 复杂指令由简单指令的组合实现.  
- 指令长度固定, 指令种类减少, 寻址方式减少.  
- 只有取数/存数(LOAD/STONE)指令访问存储器.  
- 控制器常用组合逻辑控制, 不用微程序控制.  
...


# 控制器

CPU 包括计算器与控制器两大部分.  
控制器负责协调并控制计算机各部件执行程序的指令序列, 其基本功能为 取指令, 分析指令, 执行指令.  
此外, 控制器还必须能控制程序的输入和运算结果的输出(即与I/O设备交换信息)以及总线管理等.  

CPU 的功能: 指令控制, 操作控制, 时间控制, 数据加工, 处理中断等.  


## CPU结构

- CU: 控制单元, 发出各种操作命令序列.  
- ALU: 运算器, 完成算术运算和逻辑运算.  
- 中断系统.  
- 寄存器.  

### CPU内部寄存器

- 用户可见寄存器:  
    - 通用寄存器
    - 数据寄存器
    - 地址寄存器
    - 条件码寄存器(部分透明)
- 控制和状态寄存器:
    - MAR: 存储器地址寄存器.  
    - MDR: 存储器数据寄存器.  
    - PC: 程序计数器. 用户可见.  
    - IR: 指令寄存器.  

不同CPU中, 寄存器组织不同.  

## 7.2 指令周期

指令周期: CPU每取出并执行一条指令所需的全部时间, 即CPU完成一条指令的时间.  
不同指令的指令周期不同.  

指令周期常用若干机器周期表示, 机器周期又称CPU周期.  
一个机器周期包含若干时钟周期(节拍, T周期).  

指令周期分三阶段: 取指周期, 间址周期(取操作数的有效地址), 执行周期.  


### 数据流

- 取指周期:  
    PC中存放着指令的地址, 送到MAR, CU发出读命令, 读入MDR, 送入IR, 同时CU控制PC+1.  
- 间址周期:  
    CU检查IR中的内容, 确认是否有间址操作.  
    有, 则将地址码 Ad(MDR) 送到MAR, 取出有效地址, 送入MDR.  
- 执行周期:  
    无法确定...
- 中断周期:  
    将断点(PC内容)写入栈内, 地址 MAR 为栈顶指针, 数据 MDR 为 PC内容.  
    将中断服务程序的入口地址送入PC.   


## 7.3 指令流水

指令流水即指令间的并行执行.  
指令周期的各阶段需要的部件不同, 所以可以实现指令间的并行.  

当指令分为取指和执行阶段时, 可形成二级流水.  
分为更多阶段进行并行可形成更高级流水.  

当遇到转移指令时, 其后的并行指令会失效, 造成时间损失.  

- 影响因素:  
    - 结构相关: 不同指令争用同一部件, 又称资源相关.  
    - 数据相关: 对于操作数的读写访问顺序不能改变, 可能导致数据错误.  
    - 控制相关: 主要由转移指令引起.  

- 流水线性能:  
    - 吞吐率: 单位时间内完成的指令数, 分为最大吞吐率和实际吞吐率.  
    - 加速比: 指采用流水线与串行执行之比, 当指令条数趋于无穷时, 为流水线段数(级数).  
    - 效率: 流水线的建立和排空需要时间, 工作时间 / 总时间.  


## 7.4 中断系统

- 引起中断的因素:  
    - 人为设置的中断: 称为自愿中断.  
    - 程序性事故: 由于程序设计不周而引起的中断, 各种报错.  
    - 硬件故障: ...
    - I/O设备: I/O设备就绪时会发出中断请求.  
    - 外部事件: 如, 用户通过键盘来中断现行程序.  

- 中断请求标记:  
    为判断是哪个中断源提出的请求, 在中断系统中须设置中断请求标记触发器, INTR. 为 1 时, 表示对应中断源有请求.  
    触发器也可以分散到各中断源.  

- 中断判优逻辑:  
    分为硬件排队和软件排队.  

- 寻找中断服务程序的地址:  
    - 硬件向量法: 由编译器输出向量地址, 向量地址可存放转移指令或程序地址.  
    - 软件查询法: 查询各中断源是否有中断请求, 有则执行转移指令到其中断服务程序.  

- 中断响应:  
    指令执行周期结束后会响应中断, 进入中断周期.  
    - 保护程序断点
    - 寻找中断服务程序入口地址
    - 关中断

- 中断屏蔽:  
    当CPU正在执行某个中断服务程序时, 又产生了一个中断信号, 此时如果响应新的请求, 暂停中断服务程序, 执行新的中断服务程序, 这称为**多重中断**.  
    在多重中断中, 不希望低优先级的中断信号干扰高优先级的中断, 需要有中断屏蔽.  
    所有屏蔽触发器组合成屏蔽寄存器, 存储屏蔽字.  
    每个中断源的屏蔽字的每一位对应着各个中断源, 为 1, 表示对对应中断源有屏蔽作用.  
    如: A, B, C, D 四个中断源, 优先级: A, C, D, B. 各屏蔽字为:  
    A: 1111, B: 0100, C: 0111, D: 0101.  


## 控制单元的功能

控制单元具有发出各种微操作命令(即控制信号)序列的作用.  

- 控制单元的输入信号:  
    - 时钟  
    - 指令寄存器: 根据指令的**操作码**产生不同的信号.  
    - 标志: 根据CPU的状态(程序运行结果)的标志位产生不同信号.  
    - 系统总线(控制总线)的控制信号: 中断请求 或 DMA请求.  

- 输出信号:  
    - CPU内部的控制信号: 寄存器之间的传输 和 控制ALU实现不同操作.  
    - 送至系统总线(控制总线)的信号: 主存读写, I/O读写, 中断响应等.  


### 硬布线控制器设计

将每一个微操作的输入(生产条件)与输出(命令序列)用组合逻辑的方式(类似译码器)设计.  

1. 列出微操作命令的操作时间表.  
2. 写出微操作命令的最简逻辑表达式.  
3. 画出微操作命令的逻辑图.  

这样设计思路清晰, 简单明了, 但是路线庞杂, 不规范.  


### 微程序设计

为解决硬布线控制(组合逻辑控制)线路复杂的缺点, 提出了微程序设计的设想.  

一条机器指令由一个微程序完成, 每个微程序包含若干条微指令, 一条微指令对应一个或几个微操作命令.  
将微程序存放到控制存储器中, 其内容即对应的微指令(控制信号序列).  
各微程序的取指周期, 间指周期, 中断周期的微指令相同, 所以存放一份(共用).  

- 微程序控制单元:  
    以CPU执行指令的方式执行微指令. 其部件结构也类似.  
    - 控制存储器(控存): 存放全部微程序.  
    - CMAR: 控存地址寄存器.  
    - CMDR: 控存数据寄存器.  
    - 顺序逻辑: 根据输入形成下一条微指令的地址.  


### 微指令的设计

微指令分为两段: **操作控制** 与 **顺序控制**.  
操作控制字段记录控制信号, 顺序控制指出下一条微指令的地址.  


- 微指令的编码方式:  
    1. 直接编码方式:  
        控制字段的每一位代表一个微操作命令(控制信号). 1 有效, 0 无效.  
        如果有 n 个控制信号, 就需要 n 位编码.  
    
    2. 字段直接编码方式:  
        将操作控制字段分为若干段, 将一组**互斥的微操作命令**放在一个字段内, 通过对其译码, 便对应每个微命令.  
        每个分段 n 位编码可产生 2^n 个控制信号.  

    ......


1. 水平型微指令:  
    一次能定义并执行多个并行操作的微命令.  
    优点: 微程序短, 执行速度快.  
    缺点: 微指令长, 编写微程序麻烦.  

2. 垂直型微指令:  
    一条微指令只定义一个微命令, 由微操作码字段规定具体功能.  



