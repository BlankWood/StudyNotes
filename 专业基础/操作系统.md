**操作系统**  
《计算机操作系统(第四版)》  
[王道计算机考研-操作系统](https://www.bilibili.com/video/BV1YE411D7nH)  

常见的操作系统有:  
- 电脑: Windows, Linux, Mac OS.
- 手机: Android(安卓), iOS(苹果).

# 引论

操作系统(operating system, os)是配置在计算机硬件上的第一层软件(属于系统软件), 用来控制和管理整个计算机系统的硬件和软件资源, 并为用户和应用程序提供一个简单的接口和环境.

## 操作系统的功能和目标

1. 作为用户与计算机硬件系统之间的接口 - 方便用户使用  
    - 命令接口: 允许用户直接使用
    - 程序接口: 允许用户通过程序间接使用
    - GUI: 现代操作系统中最流行的图形用户接口


2. 作为系统资源的管理者 - 安全, 高效  
    - 处理机管理
    - 储存器管理
    - 文件管理
    - 设备管理

3. 实现对计算机资源的抽象
    为了方便用户使用I/O设备, 在裸机上安装操作系统, 实现对I/O设备的操作细节, 从而用户无需关心I/O是如何具体实现的.  
    通常把覆盖了这样的软件的机器称为扩充机器或虚拟机.

具体的功能分类:  
1. 处理机管理(进程控制, 进程同步, 进程通信, 调度)
2. 存储器管理(内存分配, 内存保护, 地址映射, 内存扩充)
3. 设备管理(缓冲管理, 设备分配, 设备处理)
4. 文件管理(文件存储空间的管理, 目录管理, 文件的读写管理和保护)
5. 用户接口(用户接口, 程序接口)

现代操作系统的新功能:  
1. 系统安全
2. 网络的功能和服务
3. 支持多媒体

## 操作系统的基本特征

1. 并发  
    并发指两个或多个事件在同一时间间隔内发生. 这些事件宏观上是同时发生的, 但微观上是交替发生的.  
    并行: 指两个或多个事件在同一时刻发生.  

2. 共享  
    - 互斥共享方式: 系统中的某些资源, 如打印机、磁带机等, 虽然可以提供给多个进程使用, 但在一段时间内只允许一个进程访问该资源.  
    - 同时共享方式: 系统中的某些资源, 允许在一段时间内由多个进程"同时"访问.

如果失去并发性, 则共享性失去意义.  
如果失去共享性, 就难以实现并发.  
并发和共享是多用户(多任务)OS的两个最基本的特征, 它们互为存在条件.  

3. 虚拟  
    在OS中, 把通过某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为"虚拟".  
    - 时分复用技术: 提高设备对空闲时间的利用.  
    - 空分复用技术: 提高存储空间的利用率.

4. 异步  
    指在多道程序环境下, 系统允许多个进程并发执行, 但由于资源有限, 进程的执行并不是一贯到底的, 而是"走走停停", 以不可预知的速度进行.  

## 操作系统发展与分类

1. 手工操作方式  
    用穿孔的纸带或卡片进行输入.  
    缺点: 用户独占全机, 人工装卸时CPU等资源处于空闲状态.

2. 单道批处理系统  
    利用外围机事先将程序与数据录入磁带中, 再高速调入内存.  
    在一定程度上缓解了人机速度矛盾, 但CPU仍有大量时间是在等待I/O完成.  

3. 多道批处理系统  
    多道程序并发执行, 共享计算机资源. 资源的利用率大幅提升, CPU和其他资源保持"忙碌"状态, 系统吞吐量大.  
    但是用户的响应时间长, 且没有人机交互能力(在程序运行时, 不能与自己的作业进行交互)

4. 分时操作系统  
    计算机以时间片(如30ms)为单位轮流为各个用户/作业服务, 各个用户可通过终端与计算机进行交互.  
    主要根据人们所能接受的等待时间决定响应时间(1~3s).
    主要优点: 解决了人机交互问题. 允许多个用户同时使用一台计算机, 并且操作互相独立.  
    主要缺点: 不能优先处理一些紧急任务.

5. 实时操作系统  
    能优先响应一些紧急任务, 不需要时间片排队.  
    在实时操作系统的控制下, 计算机系统接收到外部信号后及时进行处理, 并且要在严格的时限内处理完事件. 主要的特点是**及时性和可靠性**.  
    根据严格程度分为 **硬实时系统**与**软实时系统**.  
    响应时间由控制对象所要求的截止时间来确定(毫秒级).  

6. 其他操作系统  
    - 网络操作系统
    - 分布式操作系统
    - 个人计算机操作系统

## os的运行机制与体系结构

### 运行机制

指令: 处理器(CPU)能识别, 执行的最基础命令.  
    - 特权指令(不允许用户程序使用): 如内存清零指令  
    - 非特权指令: 如普通的运算指令  

两种处理器状态:  
    - 用户态(目态): CPU只能执行非特权指令  
    - 核心态(管态): 可执行所有指令  

两种程序:  
    - 核心程序: 操作系统的内核程序是系统的管理者, 运行在核心态.  
    - 应用程序: 普通应用程序只能执行非特权指令, 运行在用户态.  

内核是计算机上配置的底层软件, 是操作系统最基本、最核心的部分。  
实现操作系统内核功能的那些程序就是内核程序。  
不同的操作系统对内核功能的划分可能并不一样。

### 体系结构

- 大内核: 将操作系统的主要功能模块都作为系统的内核, 运行在核心态.  
    - 优点: 高性能
    - 缺点: 内核代码庞大, 结构混乱, 难维护

- 微内核: 只把最基本的功能保留在内核.  
    - 优点: 内核功能少, 结构清晰, 方便维护
    - 缺点: 需要频繁地在核心态和用户态之间切换, 性能低


## 中断和异常

### 中断机制的诞生

中断机制是为了实现进程的并发.  
本质: 发生中断就意味着**需要操作系统介入,开展管理工作**.


- 当CPU收到计时部件发出的中断信号(每过一个时间片), 会切换到核心态对中断进行处理, 进行进程的切换.  
- 当进程发出**系统调用**时(内中断信号), CPU切换为核心态, 对中断进行处理.  
- 当I/O完成时, 设备会向CPU发出中断信号, CPU进行处理...


1. 当中断发生时,CPU立即进入核心态.★
2. 当中断发生后, 当前进程暂停, 并由操作系统内核对中断进行处理.
3. 对于不同的中断信号, 会进行不同的处理.

中断是从用户态转换为核心态的唯一途径.★  
从核心态转换为用户态是通过执行一个特权指令, 将程序状态字(PSW)的标志位设置为"用户态".  

### 中断的分类★

中断分为**内中断**和**外中断**, 外中断为狭义的中断.  
**内中断的信号来自CPU内部**, 与当前执行的程序有关; **外中断来自CPU外部**, 与当前执行的程序无关.  

内中断(也称异常、例外、陷入), 可分为自愿中断(指令中断)与强迫中断, 强迫中断分为硬件故障与软件中断.  
外中断分为外设请求和人工干预.  

### 外中断的处理过程

1. 执行完每个指令后, CPU都要检查当前是否有外部中断信号.
2. 检查到外部中断信号时, 需要保护被中断进程的CPU环境.
3. 根据中断信号类型转入相应的中断处理程序.
4. 恢复原进程的CPU环境并退出中断, 返回原进程继续往下执行.


## 系统调用

操作系统作为用户和计算机硬件之间的接口, 需要向上提供一些简单易用的服务. 主要包括命令接口和程序接口. 其中, 程序接口就是由一组系统调用组成.  

"系统调用" 是操作系统提供给应用程序(程序员/编程人员)使用的接口, 可以理解为一种可供应用程序调用的特殊函数, 应用程序可以发出系统调用请求来获得操作系统的服务.

### 系统调用的作用

应用程序提供系统调用请求操作系统的服务.  
系统中的各种共享资源都由操作系统统一管理, 因此在用户程序中, 凡是与资源有关的操作(如存储分配、I/O操作、文件管理等), 都必须提供系统调用的方式向操作系统提出服务请求, 由操作系统代为完成.  
这样可以保证系统的稳定性和安全性, 防止用户进行非法操作.  


- 系统调用会使处理器从用户态进入核心态.
- 一些高级语言(如C++)也是通过封装系统调用来操作系统资源.

# 进程

## 前趋图

前趋图(Directed Acyclic Graph, DAG), 是指一个有向无循环图, 它用于描述进程之间的先后顺序.  
Pi -> Pj, 表示在Pj 执行之前Pi 必须完成. 此时称Pi 是Pj的**直接前趋**, 而称Pj 是Pi 的**直接后继**.  没有前趋的结点称为**初始结点**, 没有后继的结点称为**终止结点**.  
每个结点还有一个**重量**属性.  

### 程序顺序执行与并发执行
- 顺序执行的特点  
  - 顺序性
  - 封闭性: 程序运行时独占全机资源.
  - 可再现性: 重复执行, 结果相同.

- 并发执行的特点  
  - 间断性
  - 失去封闭性
  - 不可再现性

## 进程的描述

### 进程的定义和特征

系统为每个运行的程序配置了一个数据结构, 称为**进程控制块(PCB)**.  
程序段、数据段、PCB三部分组成了**进程实体(又称进程映像)**, 进程实体简称进程.  
创建进程即创建进程实体的PCB, 撤销实体即撤销进程的PCB.  
- PCB是进程存在的唯一标识.  

引入进程实体后, 进程的定义:  
进程是进程实体的运行过程, 是系统进行资源分配和调度的一个独立单位.  

PCB组成:  
- 进程标识符: 用于唯一地标识一个进程(不重复). 
  分为, **外部标识符**和**内部标识符**. 外部标识符方便用户(进程)对进程的访问, 内部标识符方便系统对进程的使用.  
- 处理机状态: 各种寄存器值. 在进程切换时记录进程的运行情况.   
- 进程调度信息: 包括, 进程当前状态, 进程优先级等.  
- 进程控制信息: 包括, 程序和数据的地址, 资源清单等.


进程的特征:  
1. 动态性: **动态性是进程最基本的特征**. 进程的实质是进程实体的执行过程, 进程实体有一定的生命周期.  
2. 并发性: 并发.  
3. 独立性: 进程实体是一个能独立运行, 独立获得资源和独立接受调度的基本单位.  
4. 异步性: 进程的执行速度不可预知.  


### ★进程的状态与转换

三种基本状态☆:  
- 就绪态: 进程已分配到除CPU以为的所有必要资源, 只要再获得CPU, 便可立即执行.  
- 执行态: 程序正在执行.  
- 阻塞态: 进程再执行过程中由于发生某事件(如, I/O请求, 申请缓冲区失败等)暂时无法继续执行的状态.

三种状态的转换☆: 
- 就绪状态的进程被调度时转换为运行态.  
- 运行态的进程当分配的时间片已完会转换为就绪态.  
- 运行态的进程执行受阻(申请的资源正被使用等)转换为阻塞态.  
- 阻塞态的进程的阻塞被解除会转换为就绪态.  

另外两种状态: 
- 创建状态: 创建一个进程是个复杂的状态, 有多个步骤. 此时的进程处于创建状态.  
- 终止状态: 进程的终止有两个步骤, 操作系统进行善后处理和PCB清零, 回收空间. 此时为终止状态.  

状态转换:  
![进程状态转换图](https://pic.imgdb.cn/item/64d991fa1ddac507cca74ca3.jpg)  

#### 挂起操作

当挂起操作作用于某个进程时, 意味着此时该进程处于静止状态. 如果进程正在执行, 它将暂停执行. 若原本处于就绪状态, 则该进程此时暂时不接受调度.  
与之对应的操作为激活操作.  

挂起的原因:  
1. 终端用户的需要  
2. 父进程的需要:  
3. 负荷调节的需要: 挂起不重要的进程, 保证系统正常运行.  
4. 操作系统的需要: 检查运行中的资源使用情况或进行记账.  

转换:  
![带挂起的状态转换](https://pic.imgdb.cn/item/64d993f11ddac507ccaba7e2.png)  

### 进程的组织

多个进程之间的组织方式:  
1. 线性方式: 将系统所有的PCB都组织在一张线性表中. 实现简单, 开销小, 但查找需要扫描全表, 适合进程数目不多的系统.  
2. 链接方式: 将具有相同状态的进程的PCB链接成一个队列. 通常按优先级将PCB从高到低排列.  
3. 索引方式: 根据进程状态的不同, 建立几张索引表.

## 进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理, 它 具有创建新进程、撤销已有进程、实现进程状态转换等功能.  

用**原语**实现进程控制. 原语的特点是**执行期间不允许中断**. 这种不可中断的操作即**原子操作**.

### 进程的创建

在OS中, 允许一个进程创建另一个进程, 通常分别称为父进程与子进程, 子进程可以继承父进程的所拥有的资源.  
当子进程被撤销时应归还其资源; 当父进程撤销时, 应同时撤销其所有子进程.  
在Windows中不存在这种进程的层次结构, 所有进程的地位相同. 但进程创建另一个进程时会获得"句柄", 用来控制被创建的进程.  

引发创建进程的事件:  
    - 用户登录: 在分时系统中, 用户登录成功后系统会为用户创建一个进程.  
    - 作业调度: 作业被调度时会为它们创建进程.  
    - 提供服务: 用户程序提出请求后, 系统会创建进程.  
    - 应用请求: 用户进程创建子进程, 以便完成特定任务.  

进程的创建:  
    1. 申请空白PCB, 获得唯一数字标识符.  
    2. 分配其所需的资源.  
    3. 初始化PCB.  
    4. 插入就绪队列.  

### 进程的终止

- 正常结束
- 异常结束: 发生异常事件, 使程序无法继续运行. 越界, 非法指令, 运行超时, 算术运算错误等.  
- 外界干预: 操作员或系统干预, 父进程请求, 父进程终止.  

终止过程:  
    1. 从PCB集合中找到终止进程的PCB.  
    2. 若进程处于执行状态, 则立即终止.
    3. 终止其子进程.  
    4. 将其资源归还给其父进程或系统.  
    5. 将PCB移出PCB队列.  


### 阻塞与唤醒

- 向系统请求共享资源失败
- 等待某种操作的完成
- 新数据尚未到达
- 等待新任务到达

☆阻塞是进程自身的一种**主动**行为.  

当上述阻塞原因解决后会唤醒进程. 


## ★进程同步

进程同步机制的主要任务, 是对多个相关进程在执行次序上进行协调, 使并发执行的诸进程之间能按照一定的规则(或时序)共享系统资源, 从而**使程序的执行具有可再现性**.  

### 基本概念

- 两种形式的制约关系
  - 间接相互制约关系  
    某些资源在同一时刻只能有一个进程访问, 多个同时申请此类资源的进程形成间接相互制约关系.  
  - 直接相互制约关系  
    为了完成某个任务而建立了多个进程，这些进程需要合作，形成直接制约关系.  

- 临界资源
  在一个时间段内, 只允许一个进程访问的资源.  
  防止多个进程并发时, 对资源的使用或对数据的读写产生混乱.  

- 临界区
  每个进程中访问临界资源的那段代码称为临界区.  

访问临界区:
    - 进入区: 在访问之前对检查临界资源是否正在被访问.
    - 临界区
    - 退出区: 释放临界资源.  
    - 剩余区: 除此之外的其他代码

- 同步机制应遵守的规则
  - 空闲让进: 空闲时允许访问.
  - 忙则等待: 其他想进入临界区的检查必须等待.
  - 有限等待: 应保证在有限时间内进入临界区.
  - 让权等待: 不能进入临界区时, 应释放处理机.  

### 硬件同步机制

虽然可以利用软件方法解决诸进程互斥进入临界区的问题, 但有一定难度, 并且存在很大的局限性, 因而现在已经很少使用.  

1. 关中断:  
    关中断后不允许当前进程被中断, 也必要不会发生进程切换, 直到释放.  
    优点: 简单, 高效.  
    缺点: 不适用于多处理机, 不适用于用户进程(开/关中断指令只能运行在内核态), 关中断时间过长影响系统效率.  

2. Test-and-Set:  
    硬件指令 - "测试并建立"指令TS(Test-and-Set).  
    这条指令可以看作一个函数过程, 其执行过程不可分割.  
    为每个临界资源设置一个布尔变量, 传入TS函数, 一直循环到通过.  

3. Swap指令:  
    ...  


### ★信号量机制

- 整型信号量机制:  
    以一个整型变量(S)表示资源数量.  
    当请求资源时, 调用 wait(S)原子操作, 如果 S <= 0, 等待并不断测试; 如果 S > 0, 则 S--, 可以使用资源.  
    使用完后, 调用 signal(S)原子操作, S++.  
    这两个操作分别称为 P, V 操作, P(S), V(S).  

- 记录型信号:  
    用一个整形变量(value)表示资源的数目.  
    进行 wait 操作时, value--, 如果 value < 0, 表示无资源空闲, 此进程自我阻塞并插入等待列表.  
    进行 signal 操作时, value++, 如果 value <= 0, 表示有进程在等待资源, 再调用 wakeup 原语, 将等待列表的第一个进程唤醒.  

- AND型信号量:  
    当进程需要多个共享资源时, 如果一个一个地获得资源, 在未获得所需的所有资源前无法继续而又不会释放已有资源, 容易形成死锁.  
    AND同步机制: 将进程在整个运行过程中需要的所有资源, 一次全部分配, 用完一起释放.  

- 信号量集:  
    进程需要的同一资源的数量可能不止一个, 而之前的信号量只能 +1, -1. 
    在信号量集机制中, ti表示该资源的分配下限, 要求 Si >= ti, 否则不予分配.  
    di表示进程对该资源的需求量, 分配时, Si = Si - di.  
    Swait(S1,t1,d1, ..., Sn,tn,dn);  
    Ssignal(S1, d1, ..., Sn, dn);  
    
    几种特殊情况:  
    1. Swait(S, d, d), 一个信号量, 资源大于等于 d 时可分配 d 个.  
    2. Swait(S, 1, 1), 一般的记录型或互斥信号量.  
    3. Swait(S, 1, 0), 特殊且有用的信号量操作. 当 S >= 1 时, 允许多个进程进入; 当 S = 0 时, 阻止任何进程进入. 相当于一个可控开关.   


### 信号量的应用

- 实现进程互斥  
    设置一互斥信号量 mutex, 初始值为 1.  

- 实现前驱关系  
    将共享信号量初值设为 0, 等待前驱进程释放, 唤醒后继进程.


### 管理机制

...

## 经典的进程同步问题

### 生产者-消费者问题


系统中有一组生产者进程和一组消费者进程, 生产者进程每次生产一个产品(指某种数据)放入缓冲区, 消费者进程每次从缓冲区中取出一个产品使用.  
生产者, 消费者共享一个初始为空, 大小为 n 的缓冲区.  
缓冲区未满时, 生产者可将产品放入.  
缓冲区不空时, 消费者可取出产品.  
各进程互斥访问缓冲区.  

应有两组信号量, 一组用来实现互斥访问, 一组用来控制资源.  

**如果用记录型信号量, 需要先对资源信号量判断, 再判断互斥, 否则可能会产生死锁**.  

```c++
mutex = 1;    // 互斥信号量, 实现互斥访问
empty = n;    // 同步信号量, 表示空闲的缓冲区数量
full = 0;     // 同步信号量, 表示产品数量

// 生产者
producer(){
	while(1){
		product();   // 生产一个产品
		P(empty);    // 空位减少
		P(mutex);    // 互斥访问
		将产品放入缓冲区;
		V(mutex);
		V(full);     // 产品增加
	}
}

// 消费者
consumer(){
	while(1){
		P(full);     // 产品减少
		P(mutex);    // 互斥访问
		将产品放入缓冲区;
		V(mutex);
		V(empty);     // 空位增加
		consume();   // 消费一个产品
	}
}
```

- 多生产者-多消费者问题:  
	生产的产品有多个种类, 共用同一缓冲区.  
	除了上面的几个信号量外还需要各个种类产品的信号量.  


### 哲学家进餐问题

五个哲学家共用一张圆桌, 分别坐在周围的五张椅子上, 在圆桌上有五个碗和五根筷子. 他们交替思考和进餐, 进餐时使用其左边和右边的筷子. 只有拿到两只筷子时才能进餐.  

每一只筷子由一个信号量表示, 其初值为1(互斥).  

如果允许先获得一只筷子, 等待另一只筷子(记录型信号量), 则可能每人拿上一只筷子形成死锁.  
解决: 1. 进餐进餐同时最多有四个. 2. 奇数编号哲学家先拿左边的筷子, 偶数先拿右边的筷子.  

AND型信号量就没有这个问题.   

### 读者-写者问题

一个数据文件或记录可被多个进程共享, 有读进程和写进程.  
允许多个进程同时读同一个共享对象, 但不允许写进程与其他读或写进程同时访问.  

记录型信号量实现, 一个信号量(wmutex)实现读写互斥, 一个信号量(readcount)表示读进程的数量. readcount 的访问本身也是互斥的, 需要一个互斥信号量(rmutex).  
读进程访问, 如果 readcount 不为零, 则可直接访问, 且 readcount++; 如果为零, 表示没有读进程, 继续判断, 如果 wmutex == 1, 表示没有进程, 则可访问, 为零则等待.  
写进程访问需要 wmutex == 1.  

当读进程过多时, 写进程一直会等待, 需要进行限制.  
可以用一个信号量(mx)表示有写进程需要访问, 之后会阻止其后的读进程进行访问. 等待已在访问的所有读进程退出后进行写操作, 完成后释放读进程访问权. Swait(mx, 1, 0).  
还可以设置一个信号量控制读进程的最大数量.  


## 进程通信

**进程通信即进程之间的信息交换.**  
进程是分配系统资源的单位(包括内存地址空间), 因此各进程拥有的内存地址空间相互独立.  

为了保证安全, 一个进程不能直接访问另一个进程的地址空间.  
但是进程之间的信息交换又是必须实现的. 

### 进程通信的类型

- 共享存储器系统
    进程之间通过共享某些数据结构或共享存储区进行通信.  

    - 基于共享数据结构的通信方式:  
        公用数据结构, 如有界缓冲区.  
        仅适用于传递少量数据, 通信效率低.  
    - 基于共享存储区的通信方式:  
        在内存中划出一块共享存储区域, 诸进程通过对该区域的读写交换信息. 先向系统申请获得分区, 通信完成后归还.  

- 管道通信系统
    管道指连接读写进程通信的一个共享文件(pipe文件).  
    管道机制需要以下协调能力: 互斥, 同步, 确定对方是否存在.  

- 消息传递系统
    以格式化的消息(message)为单位, 将通信的数据封装在消息中, 不需要共享的存储区或数据结构. 并利用操作系统的通信命令(原语)进行传递.  
    过程透明化, 降低通信程序设计的复杂性和错误率, 成为当前应用最为广泛的一类进程间通信的机制.  

    - 直接通信方式: 利用OS的发送原语, 直接发给目标进程.  
    - 间接通信方式: 通过共享中间实体(邮箱)进行发送和接收.  

- 客户机-服务器系统
    网络环境下的主流通信实现机制.  

    主要实现方法分3类:  
    - 套接字:  
        一个套接字即一个通信标识类型的数据结构, 包含通信目的的地址, 端口号, 传输层协议等等.  
        既适用于同一计算机内部进程通信(类似管道通信), 也适用于网络中不同计算机间的进程通信.  
    - 远程过程调用和远程方法调用:  
        远程过程(函数)调用 RPC, 是一个通信协议, 用于通过网络连接的系统. 该协议允许本地进程调用远程进程, 对程序员表现为常规的过程调用, 无需额外编程.  


### 消息传递通信的实现方式

**直接消息传递系统**:  

- 直接通信原语  
    - 对称寻址方式:  
        send(receiver, message);  
        receive(sender, message);  
    - 非对称寻址方式:  
        接收进程不需要命名发送进程, 只填表示源进程的参数.  
        receive(id, message);  

- 消息的格式:  
    ...

- 进程的同步方式:  
    ...

- 通信链路:  
    为使发送进程和接收进程之间能进行通信, 必须在两者之间建立一条通信链路. 有两种方式:  
    1. 由发送进程在通信之前用显式的"建立连接"命令(原语)请求系统为之建立一条通信链路, 使用完拆除. 主要用于计算机网络中.  
    2. 无需提出建立链路的请求, 利用发送命令(原语), 系统会自动建立链路. 主要用于单机系统中.  


**信箱通信**:

- 信箱的结构  
    - 信箱头: 存放有关信箱的描述信息.  
    - 信箱体: 由若干个可以存放消息(或消息头)的信箱格组成.  

- 信箱通信原语  
    Send(mailbox, message);     // 将消息发送到指定信箱.  
    Receive(mailbox, message);  // 从指定信箱接收消息.  

- 信箱的类型  
    - 私有邮箱: 用户进程创建的邮箱, 其他进程只能发送到该邮箱, 不能查看. 随进程结束而消失.  
    - 公用邮箱: 操作系统创建, 提供给所有核准进程使用. 既可发送消息到该邮箱, 也可读取发送给自己的消息. 通常在系统运行期间始终存在.  
    - 共享邮箱: 某进程创建, 指定共享的进程后. 拥有者和共享者都可从中取走发送给自己的消息.  

## 线程(Threads)

### 基本概念

线程: 可以理解为轻量级的进程.  

在 OS 中引入进程大的目的是使多个程序能并发执行, 以提高资源利用率和系统吞吐量.  
再引入线程是为了减少程序在并发执行时所付出的时空开销, 使 OS 有更好的并发性.  
传统的进程概念和设计方法使进程的创建, 调度, 分派都需要花费较大的时间和空间开销.  

在引入线程后:  
    线程成为调度和分派的基本单位, 是能独立运行的基本单位.  
    进程之间可以并发, 一个进程的多个线程之间也可并发.  
    进程只作为**除CPU之外的系统资源的分配单位**.  

如同进程, 线程也有线程控制块TCB.  
在同一进程中, 线程的切换不会引起进程的切换; 如果切换的线程属于不同的进程, 则应先切换到对应的进程.  

### 线程的实现

- 内核支持线程(内核级线程, KST)  
    内核级线程的管理工作由操作系统内核完成. 线程调度, 切换等工作由内核负责, 内核级线程的切换需要在核心态下完成.  

- 用户级线程(ULT)  
    用户级线程无需内核的支持, 所有的线程管理工作由应用程序负责.  
    对于设置了用户级线程的系统, 其调度仍是以进程为单位.  

一些操作系统只实现内核支持线程, 一些只实现用户级线程, 还有一些同时实现了这两种类型的线程.  

在同时支持内核级线程和用户级线程的系统中, 可采用二者组合的方式: 将n个用户级线程映射到m个内核级线程上(n >= m).  
    用户级线程和内核级线程的连接方式: 多对一模型, 一对一模型, 多对多模型.  
**内核级线程才是处理机分配的单位**.  


# 处理机调度


处理机调度: 处理机调度即从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行, 以实现进程的并发执行.  

- 层次:  
    - 高级调度:  
        又称长程调度或作业调度, 它的调度对象是作业.  
        其主要功能是根据某种算法, 决定将外存上处于后备队列中的哪几个作业调入内存, 为它们创建进程, 分配必要的资源, 并将它们放入就绪队列.  
        高级调度主要用于多道批处理系统, 分时和实时系统中不设置高级调度.  

    - 低级调度:  
        又称进程调度或短程调度, 调度对象为进程(或内核级线程).  
        其主要功能是根据某种算法, 决定就绪队列中的哪几个进程应获得处理机, 并由分配程序将处理机分配给被选中的进程.  
        进程调度是最基本的一种调度, 在多道批处理, 分时, 实时中都必须配置这级调度.  

    - 中级调度:  
        又称内存调度.  
        引入的目的是, 提高内存利用率和系统吞吐量. 把暂时不能运行的进程调至外存等待, 此时进程的状态称为就绪驻外存状态(或挂起状态).  
        由中级调度决定就绪驻外存的进程被调入内存.  

-  目标:  
    - 资源利用率:  
        $CPU的利用率 = \frac{CPU有效工作时间}{CPU有效工作时间 + CPU空闲等待时间} $

    - 公平性:  
        各进程都获得合理的 CPU 时间, 不发生进程饥饿现象.  
    
    ...

周转时间: 作业被提交给系统到作业完成的时间.  
带权周转时间: 权即周转时间与系统为它提供服务的时间之比.  
系统吞吐量: 单位时间内系统完成的作业数.  

## 作业与作业调度

### 批处理系统的作业

- 作业(Job)  
    作业是一个比程序更广泛的概念, 它不仅包含了通常的程序和数据, 而且还应该配有一份作业说明书. 在批处理系统中, 是以作业为基本单位从外存调入内存的.  
- 作业步(Job Step)  
    通常在作业运行期间, 每个作业都必须经过若干相对独立, 又相互关联的顺序加工步骤. 每个加工步骤称为一个作业步.  

- 作业控制块  
    为管理和调度作业, 为每个作业设置一个作业控制块 JCB. 

- 三个阶段与三个状态  
    收容阶段(后备状态), 运行阶段(运行状态), 完成阶段(完成状态).  

### 调度算法

1. 先来先服务(FCFS)调度算法  
    可用于作业或进程调度. 在单处理系统中已很少作为主调度算法, 但经常将其与其它调度算法结合使用.  
2. 短作业优先(SJF)调度算法  
    以作业的运行时间长短来计算优先级, 越短优先级越高.  
    但作业运行时间难以预测, 对长作业非常不利, 人机无法交互, 未考虑作业紧迫程度.  

3. 优先级调度算法(PSA)  
    基于作业的紧迫程度, 由外部赋予作业相应的优先级, 根据该优先级进行调度.  
4. 高响应比优先调度算法(HRRN)  
    既考虑作业的等待时间, 又考虑作业运行时间.  
    $$优先权 ＝ \frac{等待时间＋要求服务时间}{要求服务时间} ＝ \frac{响应时间}{要求服务时间}$$  

## 进程调度

### 进程调度的任务, 机制, 方式

- 任务:  
    保存处理机的现场信息, 按某种算法选取进程, 把处理机分配给进程.  
- 机制: 为实现进程调度, 进程调度机制应有如下三个基本部分:  
    排队器: 将就绪进程按一定策略排成一个或多个队列.  
    分派器: 依据进程调度程序选定进程, 进行上下文切换, 并分配处理机.
    上下文切换器: 保存原进程的环境, 载入新进程.  
- 方式:  
    - 非抢占方式:  
        只允许进程自动放弃处理机, 一直运行到进程结束或阻塞.  
    - 抢占方式:  
        当进程正在运行时, 如果有更重要或紧急的进程需要处理机, 会让出处理机.  

### 调度算法

**轮转(RR)调度算法**:  

- 原理:  
    按就绪队列(FCFS策略), 每个进程轮流执行一个时间片.  
- 切换时机:  
    进程完成或时间片结束.  
- 时间片大小:  
    时间片小, 会增加系统切换进程的开销; 太长则影响交互需求.  
    一般略大于一次典型的交互所需时间.  


**优先级调度算法**:  

- 算法类型  
    - 非抢占式: 出现更高优先级进程时, 应先执行当前进程.  
    - 抢占式: 出现更高优先级进程时, 会调度最高优先级进程.  

- 优先级类型  
    - 静态优先级:  
        在创建进程时确定且不会改变, 用整数(优先数)表示.
        确定优先级大小的依据: 进程类型, 进程对资源的需求, 用户要求.  
    - 动态优先级:  
        创建进程时赋予一个优先级, 但会改变. 如随等待时间增长, 提高优先级.  
        这样能防止低初始优先级的进程一直不被调度.  


**多队列调度算法**:  

建立多个就绪队列, 不同的就绪队列采用不同的调度算法.  


**多级反馈队列调度算法**:  

- 设置多个就绪队列, 优先级从高到低, 时间片从小到大(逐级翻倍).  
- 每个队都采用 FCFS 算法, 在一个时间片内未完成则放入下一队列的末尾. 最后一个队列采用 RR 方式运行.  
- 当第 i 队列的进程正被执行时又有新进程进入更高优先级队列, 先就其放回 i 队末尾, 重新执行高优先级进程.   

此算法能较好地满足各类型用户的需求. 是目前公认的一种较好的进程调度算法.   

**基于公平原则的调度算法**:  

- 保证调度算法:  
    如果在系统中有 n 个相同类型的进程同时运行, 每个进程都能获得相同的处理机时间 1/n.  

- 公平分享调度算法:  
    不同的用户的进程数目可能不同, 如果要对各用户公平, 应给予各用户相同的时间片轮流执行. 或者一个用户的处理机时间是另一个的两倍...


## 实时调度

- 实现实时调度的基本条件:  
    - 必要的信息: 就绪时间, 开始截止时间和完成截止时间, 处理时间, 资源要求, 优先级.  
    - 系统处理能力强.  
    - 采用抢占式调度机制.  
    - 具有快速切换机制.  

- 分类:  
    - 非抢占式调度算法: 可用于要求不太严格的实时控制系统中.  
    - 非抢占式优先调度算法: 添加了优先级别, 可用于有一定要求的实时控制系统.  
    
    - 基于时钟中断的抢占式优先级调度算法: 时钟中断后进行抢占. 可用于大多数实时系统.  
    - 立即抢占的优先级调度算法: 当进程不处于临界区时可以立即抢占.  


### 最早截止时间优先

顾名思义,任务的截止时间越早优先级越高.  

抢占式和非抢占式都可以用.  

当截止时间相同时, 不进行切换以减小系统开销.


### 最低松弛度优先(LLF)算法

松弛度: 截止时间 - 需要的运行时间 - 当前时间.  
松弛度越低, 优先级越高.  
主要用于可抢占调度方式中.  

- 优先级倒置:  
    低优先级进程(P3)进入临界区, 此时高优先级进程(P2)抢占处理机, 之后更高优先级进程(P1)抢占处理机, 而资源被最低优先级进程占用, 只能将处理机还给P2. 之后是P3, 最后P1.

- 解决方法:  
    - 进入临界区的进程不允许被抢占. 但临界区较长时, 仍需等待很久.  
    - 动态优先级继承, 高优先级进程可将其优先级继承给占用资源的低优先级进程, 直到退出临界区.  


## 死锁概述

### 资源问题

- 可重用性资源:  
    可重复使用, 但不允许共享. 其数目相对固定.  
- 可消耗性资源:  
    又称临时性资源, 由进程动态地创建和消耗

- 可抢占性资源:  
    某进程在获得这类资源后, 该资源可以再被其他进程或系统抢占.  
- 不可抢占性资源:  
    一旦系统把某资源分配给该进程后, 就不能将它强行收回, 只能在进程用完后自行释放. 如磁带, 打印机等.  

### 死锁

- 竞争不可抢占性资源引起死锁:  
    两个进程争抢两个都需要的资源...  
- 竞争可消耗资源引起死锁:  
  
- 进程推进顺序不当引起死锁:  
  

- 死锁的定义:  
    如果一组进程中的每一个进程都在等待仅由该组进程中的其它进程才能引发的事件, 那么该组进程是死锁的.  

- 产生死锁的必要条件  
    - 互斥条件
    - 请求和保持条件
    - 不可抢占条件
    - 循环等待条件

- 处理死锁的方法
    - 预防死锁  
        通过设置某些限制条件, 破坏产生死锁的必要条件.  
    - 避免死锁  
        在资源的动态分配过程中, 用某种方法防止系统进入不安全状态, 避免死锁.  
    - 检测死锁
    - 解除死锁


## 预防死锁

通过设置某些限制条件, 破坏产生死锁的必要条件.  

- 破坏互斥条件

操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备。  
但并不是所有资源都可以改造. 并且为了系统安全, 很多地方还必须保护互斥性.  
所以主要是破坏后三个条件.  


- 破坏"请求和保持"条件

当一个进程请求资源时, 它不能持有不可抢占资源. 有两种实现协议:  

1. 所有进程在开始运行之前, 必须一次性地申请其所需的全部资源.  
    其简单, 易行且安全. 但资源浪费严重, 且会使进程饥饿.  

2. 进程运行时先释放已有资源, 再申请还需要的资源.  


- 破坏"不可抢占"条件

当一个已经保持了某些不可抢占资源的进程, 提出新的资源请求而得不到满足时, 它必须释放已经保持的所有资源.  

该方法实现比较复杂, 且需要付出很大的代价.  


- 破坏"循环等待"条件

对系统所有资源类型进行线性排序, 并赋予不同的序号.  
每个进程必须按序号递增的顺序请求资源.  
当进程运行时需要一个编号低的资源时, 它必须先释放编号在其之后的所有资源.  

采用这种策略时, 资源的序号十分重要. 一般输入设备序号较低, 输出设备序号较高.  



## 避免死锁

在资源的动态分配过程中, 用某种方法防止系统进入不安全状态, 避免死锁.  

- 系统安全状态:  
    允许进程动态地申请资源, 但系统在进行资源分配之前, 应先计算此次资源分配的安全性.  
    当系统按某种进程推进顺序分配资源, 每个进程所需的资源都能被满足, 这个进程顺序称为安全序列.  
    - 资源分配规则: 进程有最大需求量和已分配量, 系统有可用量.  
        将一部分可用量分给进程使其满足需求, 运行完成后回收资源.  
        继续分配给下一个进程... 所有进程都能得到满足的进程顺序就是安
        全序列.  
    
    **能找到安全序列, 系统就处于安全状态, 否则为不安全状态. 在不安全状态下可能会发生死锁.**  


### 银行家算法

在进程提出资源申请时, 先预判此次分配是否会导致系统进入不安全状态. 如果会, 则拒绝, 让进程先阻塞等待.  

- 数据结构  
    - 可利用资源向量 Available.  
	    表示每类资源的可用数目.  
    - 最大需求矩阵 Max.  
	    表示每个进程对各类资源的需求量.  
    - 分配矩阵 Allocation.  
	    表示每个进程已分配的资源数目.  
    - 需求矩阵 Need.  
	    表示每个进程还需要的各类资源数目.  
    Need = Max - Allocation.  

- 银行家算法  
    $Request_i$ 表示进程 $P_i$ 的资源申请向量.  
    1. 检查申请是否超过声明的最大需求数量  
        $Request_i$ ≤ Need[i]  

    2. 检查系统剩余的可用资源是否能满足此次请求  
        $Request_i$ ≤ Available  

    3. 试探着分配, 更新各数据  
        Available = Available - $Request_i$;  
        Allocation\[i] = Allocation\[i] + $Request_i$;  
        Need\[i] = Need\[i] - $Request_i$;  

    4. 用安全性算法检查此次分配是否会导致系统进入不安全状态  
        如果安全则进行分配, 否则取消分配, 恢复原数据, 让进程等待.  

- 安全性算法
    工作向量 Work = Available, 系统的剩余可分配资源.  
    完成分配标记向量 Finish, 表示各进程是否完成分配.  
    1. 找到未完成分配且可进行分配(需求小于剩余资源)的进程, 找不到则进入步骤3.  
        Finish[i] = false && Need[i] ≤ Work. (Need[i]与Work都为向量, 其中的所有元素都应满足小于等于关系)  

    2. 更新数据, 继续分配(步骤1).  
        Finish[i] = true;  
        Work = Work + Allocation[i];  

    3. 所有进程都得到满足(Finis = true), 则系统处于安全状态.  


## 死锁的检测与解除

如果既不进行预防, 也不进行避免, 系统可以进行死锁检测和解除.  

### 死锁的检测

- 资源分配图  
    结点分为**进程结点**和**资源结点**.  
    进程指向资源的边表示进程申请该资源, 资源指向进程表示资源已分配给该进程.  
    一条边表示单个(数量)资源的分配, 多个资源需要多条相同的边.  

- 死锁定理  
    找出一个既不阻塞又非独立的结点.  
    其运行完成后释放全部资源, 成为孤立的结点.  
    继续寻找, 如果能消去所有的分配边, 所有的结点成为孤立结点. 称该图是可完全简化的.  
    如果是不可完全简化的, 那么就是产生了死锁.  

- 死锁的解除  
    化简资源分配图后, 还连着的进程就是死锁进程.  
    两种常采用的解除死锁的方法:  
    1. 抢占资源: 抢占资源分配给死锁进程.  
    2. 终止(撤销)进程: 终止(或撤销)系统中的某些进程以解除死锁.  
        应考虑的因素: 进程的优先级, 已执行时间和仍需要的时间, 已使用的资源和仍需的资源, 进程的性质(交互式或批处理式).



# 存储器管理

- 存储器层次  
    $CPU \leftrightarrow cache \leftrightarrow 内存 \leftrightarrow 辅存$  
    详情查阅 [计算机组成原理-存储器](计算机组成原理.md#存储器).  
<br>
- 逻辑地址与物理地址  
    逻辑地址又称相对地址, 即指令与指令之间的相对地址.  
    物理地址又称绝对地址, 即在存储器中的地址.  
<br>
- 程序的装入和链接  
    用户程序要在系统中运行, 必须先将它装入内存, 再将其转变为一个可执行程序, 通常的步骤:  
    - 编译: 由编译程序(Compiler)对用户源程序进行编译, 形成若干个目标模块(Object), 各模块逻辑地址独立. 高级语言 -> 机器语言.  
    - 链接: 由链接程序(Linker)将编译后形成的一组目标模块以及它们所需的库函数链接在一起, 形成一个完整的装入模块(Load Module), 逻辑地址整合.  
    - 装入: 由装入程序(Loader)将装入模块装入内存.  

<br>

- 操作系统的内存管理  
    - 负责内存空间的分配和回收.  
    - 用虚拟技术对内存空间扩充.  
    - 提供地址转换功能, 逻辑地址与物理地址的转换.  
    - 提供内存保护, 各进程在各自的存储空间内运行, 互不干扰.  

<br>

- 内存空间的扩充  
    1. 覆盖技术: 解决程序大小超过物理内存的问题.  
        将程序分段(模块), 内存分为一个"固定区"和若干"覆盖区".  
        只用于早期的操作系统.  
    2. 交换技术  
        内存空间紧张时, 将某些进程暂时换出外存(挂起).  
        将磁盘空间的一小部分划分为对换区. 其外的部分称为文件区. 对换区的I/O速度比文件区更快.  
    3. 虚拟存储技术...  


## 程序的装入与链接方式

- 装入:  
	<br>
	1. 绝对装入方式  
	    在编译时, 如果知道程序将放到内存中的哪个位置, 编译程序将产生绝对地址的目标代码.  
	    装入程序将按照装入模块中的地址, 将程序和数据装入内存.  
		绝对装入方式只适用于单道程序环境. 在多道程序环境下, 编译程序不可能预知目标模块放入内存的位置.  
	<br>
	1. 可重定位装入方式  
	    编译的目标模块的起始地址通常都是从 0 开始, 其它地址都是基于相对起始地址计算的.  
	    在装入时根据内存情况装入到适当位置.  
	    装入时对地址进行"重定位", 将逻辑地址转变为物理地址.  
		可重定位装入方式不允许程序允许时在内存中移动位置, 一旦移动, 装入时转换的物理地址将失效.  
	<br>
	1. 动态运行时装入  
	    把装入模块装入内存后, 并不立即把逻辑地址转换为物理地址, 而是推迟到程序真正要执行时进行.  
	    实现依赖于一个重定位寄存器, 记录起始地址.  

<br>

- 链接:  
	<br>
	1. 静态链接  
	    在程序运行之前, 先将各目标模块及它们所需的库函数链接成一个完整的装配模块(可执行文件), 之后不再拆开.  
	<br>
	1. 装入时动态链接  
	    装入内存时, 采用边装入边链接的链接方式.  
	    各目标模块分开存放.  
	<br>
	1. 运行时动态链接  
	    在程序执行中需要该目标模块时, 才对它进行链接.  
	    未被用到的目标模块不会被调入内存和被链接到装入模块上.  


## 连续分配存储管理方式

<br>

为用户进程分配一个连续的内存空间.  

内部碎片: 分配给某进程的内存区域中, 未被利用的空间.  
外部碎片: 内存中的某些空闲分区由于太小而难以利用.  

- 单一连续分配  
    在单道程序环境下, 将内存分为**系统区**和**用户区**.  
    系统区仅提供给 OS 使用, 通常放在内存的低地址部分. 用户区只有一道用户程序.  
<br>
- 固定分区分配  
    将用户空间划分为若干个固定大小的区域, 每个分区只装入一道作业.  
    - 划分方法:  
        1. 大小相等, 同时控制多个相同对象的场合使用.  
        2. 大小不等, 分配灵活, 根据用户的需求来划分.  
    - 内存分配:  
        通常将分区按大小排序, 并建立一张使用表记录分区相关信息(大小, 起始地址, 状态).  
    
    固定分配必然会造成存储空间的浪费, 现在已很少使用.  

<br>

- 动态分区分配  
    又称可变分区分配.  
    - 数据结构:  
        通常的数据结构有两种形式:  
        空闲分区表, 空闲分区链(双向).  
    - 分配算法:  
        从空闲分区表(链)中选出一个分区分配给作业. 详细介绍在下文**动态分区分配算法**中.  
    - 回收内存:  
        分为四种情况, 前方为空闲分区, 则更改前分区大小; 后方为空闲分区, ...; 前后均为空闲区; 无空闲区相邻;  
        **总之, 相邻的空闲分区需要合并.**   


### 动态分区分配算法

**基于顺序搜索的动态分区分配算法**:  

- 首次适应(first fit, FF)算法/循环首次适应(next fit, NF)算法:  
    空闲分区链以地址递增的次序链接.  
    从链首开始查找, 直至找到大小满足要求的空闲分区.  
    按作业大小, 划分空间, 余下的空间保留在链中.  
    如果是循环的话, 下次分配的起点为上次分配查找的终点.  
<br>
- 最佳适应(best fit, BF)算法:  
    将空闲分区按从小到大的顺序排列.  
    查找满足要求的第一个分区.  
    这样会留下许多外部碎片.  
<br>
- 最坏适应(worst fit, WF)算法:  
    将空闲分区按从大到小的顺序排列.  
    将第一个分区分割一部分给作业.  
    这样产生碎片的可能性小, 但缺少大的空闲分区.  

**基于索引搜索的动态分区分配算法**:  

- 快速适应(quick fit)算法:  
    又称分类搜索法, 将空闲分区根据其容量大小进行分类, 每类单独建立链表.  
    用一张表管理链表, 记录其信息. 分类的标准可以是 2 KB, 4 KB, 8 KB等, 其间的可以放在临近的类别中, 或特殊类中.  
<br>
- 伙伴系统(buddy system):  
    所有分区大小都为 2的k次幂.  
    将不同大小的分区进行分类.  
    找到满足要求的最小空间大小类别, 如果此类空间以用完, 则将更大的空间分两半.  
    回收时也可能需要多次合并.  
<br>
- 哈希算法:  
    空间分类时, 利用哈希算法实现快速查找到对应的分类链表.  
<br>
- 动态可重定位分区分配:  
    - 紧凑:  
        系统或用户程序必须装入连续的内存空间.  
        而当计算机运行一段时间后, 内存将会被分割成许多小的分区.  
        此时需要通过 "拼接"(或称"紧凑"), 将内存中的所有作业移动, 将所有空闲分区拼接成一个大分区.  
        移动时必须对程序或数据进行重定位.  

    - 算法:  
        当空闲分区没有可用的分区时, 检测空闲分区总和是否满足需求, 满足则进行"紧凑".  


## 分页存储管理方式

连续分配会产生许多碎片, 虽然可以通过"紧凑"的方式进行拼接, 但其需要很大的开销.  

非连续(离散)分配方式:  
将一个进程分页或分段, 分散地装入到许多不相邻的分区中.  
- 分页存储管理方式: 典型的页面大小为 1 KB.  
- 分段存储管理方式: 主程序段, 数据段...  
- 段页式存储管理方式: 结合分段分页, 是目前应用较为广泛的一种存储管理方式.  

### 基本概念

- 页面和物理块:  
    将进程的地址空间分为若干页(页面), 并加以编号.  
    相应地, 内存也分成若干块(页框), 加以编号.  
    将若干页装入不相邻的物理块中, 最后不满的碎片称为"页内碎片".  
    页面大小通常为 1KB ~ 8KB(2^n).  
<br>
- 页表:  
    每个进程都会建立一张页表, 记录其页对应的物理块号.  
    每条记录称为一个页表项: 页号, 块号.  
    因为页号是连续的, 可以隐藏(去除), 直接用数组只记录块号即可.  

相对地址分为页号与页内地址(偏移量).  
| 页号 k位 | 偏移量 m位 |.  
☆进程最多页面数: 2^k, 页面大小: 2^m.  

页号 = 逻辑地址 / 页面大小 (向下取整)  
偏移量 = 逻辑地址 % 页面大小  


### 地址变换机构

将逻辑地址转换为物理地址.  

- ☆基本的地址变换机构:  
    页表寄存器 PTR: 进程运行时将其页表起始地址和页表长度(页表项的个数)放入 PTR, 进行地址计算.  
    根据页表长度将逻辑地址分为两段, 前段为页号, 后段为偏移量.  
    先以页号与页表长度比较, 检测是否越界, 再进行检索, 找到对应物理块号.  
    > 页表项长度: 记录一个物理块地址所用的存储空间大小.  
    > 找到内存中记录物理块号的地址:  
    > 页号 x 页表项长度 + 页表起始地址, 其内容即物理块号.  
    > 页表的内容通常是装在连续的内存块中.  
    
    物理地址 = | 物理块号 | 偏移量 |, 即 物理地址 = 物理块号 X 页面大小 + 偏移量.  

- 具有快表的地址变换机构:  
    页表是放在内存中的, 因此CPU每次存取数据需要访问内存两次: 先访问页表计算物理地址, 再访问内存取出数据.  
    所以需要一个特殊寄存器, 称为 "联想寄存器" 或 "快表"(TLB), 用以存放当前访问的页表项.  
    思路类似于高速缓存.  
    - 过程:  
        得到相对地址的页号后不去内存的页表找, 而是去快表找. 如果有记录, 则直接取出物理块号; 没有, 则再去内存找.  

- 两级和多级页表:  
    当逻辑地址空间较大时, 需要的页表空间页就越大, 而且页表的空间是连续的. 
    1. 页表可以离散分配.  
    2. 只将当前需要的部分页表调入内存, 其余的留着磁盘上.  

    离散的页表也需要建立一种页表进行记录, 称为 "外层页表".  
    相对地址 = | 外层页号 | 外层页内地址 | 页内地址 |  
    各级页表大小不超过一个页面.  
    同样需要一个外层页表寄存器.  

    在两级页表中, 如果没有快表, 需要访问三次内存.  

    第二点将在虚拟存储器一章介绍.  


## 分段存储管理方式

分页的大小是固定的,  而程序的分段的大小是不固定的, 如主程序段, 子程序段, 数据段，栈段等。  
所以需要分段存储管理方式。  

- 方便编程
- 信息共享
- 信息保护
- 动态增长
- 动态链接

### 基本原理

作业的地址空间被分为若干段，每段都有段名，通常以段号代替。  
每段都从 0 开始编址，并采用一段连续的地址空间，长度不定。
逻辑地址 = | 段号 | 段内地址 |  

段表:  
段表记录每个段的**段长**和**起始地址(基址)**.  

- 地址变换机构  
    段表寄存器: 存放段表始址和段表长度TL.  
    先进行越界判断, 由于每段段长不固定, 所以判断稍显复杂.  
    其后就可算出物理地址.  






# 虚拟存储器

## 概述

传统存储器管理方式特征:  
    - 一次性: 作业必须一次性地全部装入内存后才开始运行.  
    - 驻留性: 作业被装入内存后, 会一直留在内存中, 直到作业运行结束.  

局部性原理:  
程序在运行时, 在较短时间内, 只会访问局部区域, 在时间上也是重复访问一些数据或指令.  

基于局部性原理可知, 没必要将程序全部都装入内存中, 只装入当前需要的部分.  
如果发现程序需要的页(段)未调入内存(缺页或缺段), 便发出缺页(段)中断请求, 再调入内存.  

- 定义:  
    虚拟存储器, 指具有请求调入功能和置换功能, 能从逻辑上对内存容量加以扩充的一种存储器系统.  

- 特征:  
    - 多次性: 一个作业会分多次调入内存运行, 即只需装入当前要运行的那部分程序和数据即可开始运行.  
    - 对换性: 将暂时不用的代码和数据从内存调至外存的对换区(换出), 将需要的调入内存(换进).  
    - 虚拟性: 指用户看到的内存容量大于实际内存量.  

## 实现方法

- 请求分页系统: 在分页系统的基础上增加请求调页和页面置换功能.  
- 请求分段系统: 在分段系统的基础上增加请求调段和分段置换功能.


## 请求分页存储管理方式

- 请求页表机制:  
    页表项: | 页号 | 物理块号 | 状态位P | 访问字段A | 修改位M | 外存地址 |  
    - 状态位(存在位)P: 指示该页是否已调入内存.  
    - 访问字段A: 记录本页在一定时间内被访问的次数, 或者距上次访问的时间. 在换页时提供参考.  
    - 修改位M: 标识本页在调入内存后是否被修改.  
    - 外存地址: 该页在外存的地址(物理块号).  

- 缺页中断机构:  
    当需要访问的页面不在内存时, 便产生缺页中断, 由 OS 转入缺页中断处理程序.  
    特征:  
    - 在指令执行期间产生和处理中断信号.  
    - 一条指令的执行期间可能产生多次缺页中断.  

- 内存分配:  
    - 进程所需的最小物理块数: 块数少会增加缺页率, 最小块数与计算机的硬件结构有关.  
    - 内存分配策略: 1. 固定分配局部置换. 2. 可变分配全局置换. 3. 可变分配局部置换.  

- 页面调入
    请求分页系统将外存分为 **对换区** 和 **文件区**.  
    对换区通常采用连续分配方式, 读取速度更高.  
    如果系统拥有足够的对换区空间, 可以全部从对换区调入页面(先拷贝至对换区). 没有, 则将不会被修改的文件直接从文件区调入, 调出时也不必写回.  
    unix方式, 未运行过的页面都从文件区调入. 之后从对换区调入.  

### 页面置换算法

1. 最佳置换算法: 
    选择未来最久不会访问的页面换出, 但难(无)以(法)实现.  
2. 先进先出算法:  
    先进先出...
3. 最久未使用/最少使用:  
    设置一个n位寄存器. 访问时, 将最高位置 1, 每隔一段时间(如100ms)右移一次. 此数可表示未访问的时间或访问的次数.    
4. Clock置换算法:
    每页设置一个访问位(A), 将所有页连成循环队列, 访问时将访问位置为 1. 置换时, 按顺序检测, 如果为 0, 则换出; 为 1, 则置为 0.  
    改进:  
    增加一个修改位(M), 如果被修改过, 此位置 1. 置换时:  
    1.寻找 A=0, M=0 的页面换出.  
    2.寻找 A=0, M=1 的页面, 同时将 A 置 0.  
    3.寻找 A=0, M=0 的页面.  
    4.寻找 A=0, M=1 的页面.  

5. 页面缓冲算法:  
    - 空闲页面链表: 空闲物理块链表. 当未被修改的页要被换出时, 将其放置此链表尾部. 如果此后仍需要访问, 则可以取出.  
    - 修改页面链表: 由已被修改的页面连成的链表. 一个已修改的页面需要被换出时, 并不立即换出, 先挂在此链表尾部.  


### "抖动"与工作集

- 抖动:  
    当进程数量过高, 而分配的物理块数小于所需的必要物理块数, 会导致处理机的利用率降低. 频繁发生的缺页会产生巨大的消耗.  

- 工作集:  
    在某时间段内, 进程实际访问的页面的集合. 
    为较少产生缺页, 应将程序的全部工作集装入内存. 但无法事先预知.  
    工作集的页面个数称为 "窗口尺寸(Δ)".  
    工作集是 时间(t) 与 窗口尺寸(Δ) 的 二元函数.  

## 请求分段存储管理方式

...


# 输入输出系统

## I/O系统的层次结构

- 用户层I/O软件:  
    与用户交互的接口.  
    不属于I/O系统.  


- 设备独立性软件:  
    也称为与设备无关的软件.  
    用于实现用户程序与设备驱动器的统一接口, 设备命名, 设备的保护以及设备的分配与释放等.  
    软件独立于具体使用的物理设备.  

- 设备驱动程序:  
    与硬件直接相关, 驱动设备工作的程序.  
    将抽象的I/O命令转为I/O设备的具体命令和参数.  
    由制造厂商提供.  

- 中断处理程序: 
    当I/O设备发来中断请求时, 负责CPU环境保存和恢复, 以及转入设备的中断处理程序.  


## I/O系统接口

在用户层I/O软件 与 I/O系统 之间由根据设备类型不同提供不同接口.  

- 块设备接口:  
    块设备: 数据的存取, 传输以数据块为单位的设备. 如 磁盘.  
    特征为: 速度快, 可寻址.  

    隐藏设备的物理结构, 将具体的操作细节抽象为简单的命令, 如 读写, 关闭命令. 

- 流设备接口:  
    流设备: 数据存取, 传输以字符为单位的设备. 如 键盘, 打印机.  
    由于不可寻址, 会建立字符缓冲区(队列), 进行内存与设备信息交流, get与put.  

- *网络接口:  
    网络套接字: 申请的一片内存空间, 用于接收和发送数据.  
    将套接字绑定本机端口.  
    收发的地址以**IP地址**和**端口号**确定.  

    网络控制器负责发送和接收.  


## I/O控制器

- 设备控制器的基本功能:  
    - 接收和识别命令
    - 数据交换
    - 标识和报告设备的状态
    - 地址识别
    - 数据缓冲区
    - 差错控制

- 设备控制器的组成:  
    - 控制器与CPU的接口: 数据线, 地址线, 控制线.  
    - 控制器与设备的接口
    - I/O逻辑: 用于实现对设备的控制.  

- 内存映像I/O:  
    将I/O命令转换, 传入设备的寄存器, 有两种方式:  
    - 独立编址(特定的I/O指令): 指令采用独立于内存的编址方式, 需要指定设备及其寄存器.  
    - 内存映像I/O: 内存地址与设备寄存器地址采用同一编址方式, 在0~n为内存, 其后为设备控制器的寄存器地址.  


## I/O控制方式

CPU向设备发送命令, 设备有一个启动和准备工作的过程.  

- 程序轮询:
    启动设备后不断循环查询设备的状态, 直到完成.  

- 程序中断:  
    发送命令后, 设备启动, CPU便返回执行原程序. 设备完成后向CPU发送中断信号, CPU转为处理.  

- DMA方式:  
    数据传输单位提升为数据块, 减少CPU中断.  
    直接从设备读写至内存, 而不用经过CPU. 只有在传输开始与结束时, 才需要中断CPU.  

- I/O通道方式:  
    将读写单位由一个数据块提升至一组数据块.  
    I/O通道可以由通道指令进行控制, CPU只需向通道发送一组通道指令来进行I/O控制.  


## 假脱机(Spooling)系统

属于用户层I/O软件.  

- 假脱机技术:  
    为了缓和 CPU 与 I/O设备 的速度矛盾, 而引入了脱机技术.  
    将低速的I/O设备的数据传入高速磁盘上, 或者相反.  
    以程序来模拟外围控制机, 即为假脱机技术(SPOOLing).  

- SPOOLing的组成:  
    - 输入输出井: 在磁盘上划分的两个存储区域, 以存储输入输出的数据(井文件).  
    - 输入输出缓冲区: 内存中的两个区域, 缓和CPU与磁盘的速度不匹配.  
    - 输入输出进程: 用于模拟外围机, 进行磁盘与CPU间的输入输出.  
    - 井管理程序: 用于控制井与作业间的信息交换.      
    
## 设备的分配与回收

属于设备独立性软件.  

- 设备分配中的数据结构:  
    | 设备控制表(DCT) |  
    | -------------- |
    |   设备类型 |
    |   设备标识符 |
    |   设备状态 |
    |   指向控制器表的指针: 每个设备都由一个控制器控制. |
    |   重复执行次数或时间: 当重复执行多次I/O后仍不成功, 才认为此次I/O失败. |
    |   设备队列的队首指针: 指向正在等待该设备的进程队列(PCB队列). |

    | 控制器控制表(COCT) |
    | ----------------- |
    | 控制器标识符: 控制器唯一ID |
    | 控制器状态: 忙碌/空闲/故障... |
    | 指向通道表的指针: 每个控制器由一个通道控制 |
    | 控制器队列的队首指针: 指向正在等待该控制器的进程队列 |
    | 控制器队列的队尾指针 |

    | 通道控制表(CHCT) |
    | --------------- |
    | 通道标识符 |
    | 通道状态   |
    | 与通道连接的控制器表首址 |
    | 通道队列的队首指针 |
    | 通道队列的队尾指针 |

    系统设备表(SDT): 记录系统中全部设备的情况, 每个设备占一个表目.  
    表目: 设备类型, 设备标识符, DCT, 驱动程序入口.  


- 设备分配步骤:  
    1. 根据进程请求的**物理设备名**查找SDT.  
    2. 根据SDT找到DCT, 若设备忙碌则将PCB挂到设备等待队列.  
    3. 分配控制器, 与 2 类似.  
    4. 分配通道, 与 2 类似.  

    只有设备, 控制器, 通道都分配成功时, 此次分配才算成功, 才能启动I/O设备.  


- 设备分配的改进:  
    使用逻辑设备名而非物理设备名, 建立逻辑设备名到物理设备名的映射机制.  

    映射方式:  
    逻辑设备表(LUT): 逻辑设备名, 物理设备名, 设备驱动程序地址.  

    根据逻辑设备名查找SDT时, 会不断查找相同的逻辑设备名, 直到找到空闲的或遍历完.  


## 缓冲区管理

由硬件寄存器组作为缓冲区, 速度非常高, 但成本高, 容量小.  
一般利用内存作为缓冲区.  

缓冲区的作用:  
- 缓和 CPU 与 I/O设备间速度不匹配的问题.  
- 减少对 CPU 的中断频率， 放宽对 CPU 中断响应的时间限制.  
- 解决数据粒度不匹配的问题.  
- 提高 CPU 和 I/O设备之间的并行性.  

一般一个缓冲区的大小为一个块.  
**当缓冲区为空可写入, 当缓冲区满时, 可取出.**  

- 单缓冲区:  
    用户进程发出I/O请求时, OS为其分配一个缓冲区.  
    设从I/O设备输入到缓冲区的时间为 T, 缓冲区到用户区的时间为 M, CPU的处理时间为 C.  
    由于 T 与 C 可并行, 一般 T > C.  
    系统对每块数据的处理时间为 Max(T, C) + M.  

- 双缓冲区:  
    缓冲区为共享资源, 生产者与消费者必须互斥访问, 需要相互等待.  
    双缓冲区可实现, 往一块输入, 同时从另一块读出.  
    系统处理一块数据的时间可以认为是 Max(C, T).  

    在实现两台机器之间的通信时, 可以用双缓冲实现双向数据传输.  

- 环形缓冲区:  
    多个缓冲区形成环形队列, 由三个指针分别指向空缓冲区队首(Nexti), 正在使用的缓冲区(Current), 满缓冲区队首(Nextg).  
    当 Nexti 追上 Nextg 时说明所有缓冲区都已满, 应阻塞输入进程.  

- 缓冲池:  
    为提高缓冲区的利用率, 由系统设置多个公用缓冲区供多个进程共享.  
    将缓冲区分为三个队列: 空白缓冲队列 emq, 输入队列 inq, 输出队列 outq.  
    四种工作缓冲区: 收容/提取 输入/输出的工作缓冲区.  

    即将数据分为输入输出两种, 分别进行收容和提取.  


## 磁盘

- 结构:  
    磁盘有一个或多个物理盘片, 每个盘片分一个或两个存储面.  
    每个盘面上有若干磁道(环形), 磁道间留有必要的间隙.  
    每个磁道被划分为若干扇区, 硬盘有数百个扇区, 扇区间也有间隙.  

    现代磁盘内外的扇区数目不同, 外层拥有更多的扇区.  


### 磁盘调度算法

- 磁盘访问时间:  
    - 寻道时间: 将磁臂(磁头)移动到指定磁道上所需的时间, 启动时间 加 移动n条磁道的时间: m x n + s.  
    - 旋转延迟时间: 将指定扇区移动到磁头下的时间, 与磁盘转速有关.  
    - 传输时间: 与磁盘转速线性相关.  

- 先来先服务:  
    仅适用于请求磁盘I/O的进程数目较少的情况.  

- 最短寻道时间优先:  
    每次选择此时最近的磁道访问. 但这样不能保证平均寻道时间最短.  
    可能会此时"饥饿"现象.  

- 扫描算法:  
    只有到达边缘的时候(更外层或内层无需要访问的磁道)才转方向, 也称为 电梯调度算法.  

- 循环扫描算法:  
    磁头单向移动. 例如, 只能自里向外移动, 当到达最外层后, 立即返回到最里层需要访问的磁道.  

- NstepSCAN:  
    当某些进程反复请求同一磁道时, 会垄断这个磁盘, 磁臂停留在一磁道不动, 即"磁臂粘着".  
    N 步 SCAN 算法 将请求队列分成若干长度为n的子队列, 按SCAN算法处理. 新来的放入另外的队列.  

- FSCAN:  
    对n步scan的简化, 分为两个队列, 正在处理的和新到的. 新到的会等待下一个扫描时进行处理.  



# 文件管理

## 简介

### 数据项与记录与文件

- 数据项:  
    - 基本数据项:  
        描述一个对象的某种属性的字符集, 是数据组织中可以命名的最小逻辑单位, 又称 **字段**.  
    - 组合数据项:
        由若干基本数据项组成的, 简称组项.

- 记录:  
    记录是一组相关数据项的集合, 用于描述一个对象在某方面的属性.  
    能**唯一标识一个记录**的**一个或多个数据项的集合**称为**关键字(key)**.  

- 文件:  
    文件是指由创建者所定义的, 具有文件名的一组相关元素的集合, 可分为 **有结构文件** 和 **无结构文件**.  
    有结构文件(记录式文件): 文件由若干相关记录组成.  
    无结构文件(流式文件): 数据为二进制流或字符流.  


### 文件类型

- 按用途分类:  
    - 系统文件:  
        由系统软件构成的文件.  
        大部分系统文件只允许用户调用, 不允许读写. 有的系统文件不直接对用户开放.  
    - 用户文件:  
        由用户的源代码, 目标文件, 可执行文件或数据等构成的文件.  
    - 库文件:  
        由标准子例程及常用的例程等所构成的文件.  
        允许调用, 不允许修改.  

- 按文件的**数据形式**分类:  
    - 源文件:  
        由源程序和数据构成的文件.  
    - 目标文件:  
        把源程序进行编译, 但未链接的目标代码所构成的文件.  
        后缀为 ".obj"  
    - 可执行文件:  
        将目标代码进行链接形成的文件.  
        后缀为 ".exe"

- 按存取控制属性分类:  
    - 只执行文件
    - 只读文件
    - 读写文件

- 按组织形式, 处理方式分类:  
    - 普通文件
    - 目录文件
    - 特殊文件: 特指系统中的各类 I/O 设备. 系统将设备视为文件管理.  



## 文件的逻辑结构

文件的逻辑结构指从用户视角所看到文件组织形式.  
独立于文件的物理结构.  
又称文件组织.  

根据文件的组织方式, 可将有结构文件分为三类: 顺序文件, 索引文件, 索引顺序文件.  
- 顺序文件:  
	记录按某顺序排列形成的文件, 记录可以为定长或可变长.  
- 索引文件:  
	为可变长记录文件建立一张索引表, 为每个记录设置一个表项, 已加速对记录的检索速度. 索引表本身为定长记录的顺序文件.  
- 索引顺序文件:  
	索引表项记录的不是单个记录, 而是一组记录的第一个. 每组记录按顺序排列.   


### 顺序文件

- 排列方式:  
    - 串结构: 按存入时间先后进行排列.  
    - 顺序结构: 按关键字进行排序.  

- 优缺点:  
    - 存取效率高.  
    - 查找, 修改效率低.  
    - 增删困难.  

- 寻址:  
    定长记录的文件寻址较简单.  
    变长记录的文件需要从头检索或查找关键字.  


### 索引文件

具有索引表的文件(变长记录文件)称为索引文件.  

按关键字建立索引表, 可以有多个索引表.  

多用于对信息处理的及时性要求比较高的场合.  


## 文件目录

### 文件控制块

文件控制块: 用于描述和控制文件的数据结构.  
文件控制块的有序集合称为文件目录, 即一个文件目录项就是一个文件控制块.  
一个文件目录也是一个文件, 即目录文件.  

文件控制块通常含有三类信息:  
- 基本信息类:  
    包括: 文件名, 文件物理位置, 文件逻辑结构, 文件物理结构.  
- 存取控制信息类:  
    包括: 文件主的存取权限, 核准用户的存取权限, 一般用户的存取权限.  
- 使用信息类:  
    包括: 文件的建立日期与时间, 上次修改的时间, 当前的使用信息.  


索引节点:  
在检索目录文件的过程中, 只需要文件名, 因此可以将文件控制块中的其它信息独立为索引节点, 目录项中存放文件名和指向对应节点的指针.  
以此可以降低目录文件的大小, 减少检索的时间.  

### 目录结构

- 单级目录结构:  
    整个文件系统中只有一张目录表, 每个文件占一个目录项.  
    不允许文件重名.  

- 两级目录结构:  
    分为主文件目录, 用户文件目录.  
    主文件目录记录 用户名 及其相应 用户文件目录 的存放位置.  

- 树型结构目录:  
    通过路径访问各文件...  





